<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>Lambda Terms</title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link rel="stylesheet" href="../../../styles/style.css">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" type="text/javascript"></script>
  <script src="../../../js/macros.js" type="text/javascript"></script>
</head>
<body>
<article>
<header>
<h1 class="title">Lambda Terms</h1>

</header>
<section class="level2">
<h2>Contents</h2>
<ul>
<li><a href="#frontmatter">Frontmatter</a></li>
<li><a href="#syntax">Syntax</a></li>
<li><a href="#free-and-bound-variables">Free and Bound Variables</a></li>
<li><a href="#alpha-equivalence">Alpha Equivalence</a></li>
</ul>
</section>
<section class="level2">
<h2>Frontmatter</h2>
<p>This module is literate Haskell and contains a mix of proofs and code. The following boilerplate has to be included here at the beginning.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">module</span> <span class="dt">Fungus.LambdaTerm</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">M</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Set</span> <span class="kw">as</span> <span class="dt">S</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="kw">import</span>           <span class="dt">Test.QuickCheck</span></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="kw">import</span>           <span class="dt">Test.QuickCheck.Property</span></a>
<a class="sourceLine" id="cb1-8" title="8"></a>
<a class="sourceLine" id="cb1-9" title="9"><span class="kw">import</span> <span class="dt">Fungus.ParserUtils</span></a></code></pre></div>
<p>I'm following the approach (particularly for substitution) given in <a href="../../bibliography.html#crossref-0">Stoughton88</a> almost verbatim.</p>
</section>
<section class="level2">
<h2>Syntax</h2>
<p>In this section we'll define the syntax of lambda calculus as a set of <em>strings</em>. We use <code>monospaced characters</code> to represent literal strings while <em>italicized characters</em> are string variables; concatenation of strings is denoted by juxtaposition. If <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are sets of strings, then <span class="math inline">\(AB\)</span> denotes the set of all pairwise concatenations of strings in <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>.</p>
<div class="definition">
<p>(<span class="math inline">\(\lambda\)</span>-terms.) Let <span class="math inline">\(\LambdaIdents\)</span> denote the set of nonempty strings of latin alphanumeric characters whose first character is a lower case letter. Let <span class="math inline">\(\LambdaConsts\)</span> be a set of nonempty strings whose first character is not <span class="math inline">\(\lambda\)</span>, <code>@</code>, <code>(</code>, or a lower case letter. The set <span class="math inline">\(\LambdaTerms\)</span> of <span class="math inline">\(\lambda\)</span>-<em>terms</em> is the smallest set of strings which satisfies the following.</p>
<ol>
<li>If <span class="math inline">\(x \in \LambdaIdents\)</span>, then <span class="math inline">\(x \in \LambdaTerms\)</span>; strings of this form are called <em>variables</em>.</li>
<li>If <span class="math inline">\(c \in \LambdaConsts\)</span>, then <span class="math inline">\(c \in \LambdaTerms\)</span>; strings of this form are called <em>constants</em>.</li>
<li>If <span class="math inline">\(x \in \LambdaIdents\)</span> and <span class="math inline">\(e \in \LambdaTerms\)</span>, then <span class="math inline">\(\lamex{x}{e} \in \LambdaTerms\)</span>.</li>
<li>If <span class="math inline">\(x \in \LambdaIdents\)</span> and <span class="math inline">\(e_1, e_2 \in \LambdaTerms\)</span>, then <span class="math inline">\(\letin{x}{e_1}{e_2} \in \LambdaTerms\)</span>.</li>
<li>If <span class="math inline">\(e_1, e_2 \in \LambdaTerms\)</span>, then <span class="math inline">\(\apply{e_1}{e_2} \in \LambdaTerms\)</span>.</li>
</ol>
</div>
<p>It may seem odd at first to define a set by invoking its minimalness like this. To see why this is ok, consider the (small) class of all sets of strings which are "closed" in the sense described by the definition of <span class="math inline">\(\LambdaTerms\)</span>. This class is not empty since it includes the set of all strings as a member, and the <span class="math inline">\(n\)</span>-ary intersection of closed sets is again closed, so we can take the intersection of the class.</p>
<p>We can also give a concrete description of <span class="math inline">\(\LambdaTerms\)</span> which is handy for writing proofs.</p>
<div class="theorem">
<p>Define a sequence <span class="math inline">\(S_n\)</span> for <span class="math inline">\(n \in \nats\)</span> recursively as follows.</p>
<p><span class="math display">\[\begin{eqnarray*}
S_0 &amp; = &amp; \LambdaIdents \cup \LambdaConsts \\
S_{n+1} &amp; = &amp; S_n \\
 &amp; &amp; \cup \, \{ \lamex{x}{e} \mid x \in \LambdaIdents, e \in S_n \} \\
 &amp; &amp; \cup \, \{ \letin{x}{e_1}{e_2} \mid x \in \LambdaIdents, e_1, e_2 \in S_n \} \\
 &amp; &amp; \cup \, \{ \apply{e_1}{e_2} \mid e_1, e_2 \in S_n \}
\end{eqnarray*}\]</span></p>
<p>Then <span class="math inline">\(\bigcup_{i \in \nats} S_i = \LambdaTerms\)</span>.</p>
<div class="proof">
<p>First we show that <span class="math inline">\(S_i \subseteq \LambdaTerms\)</span> for all <span class="math inline">\(i \in \nats\)</span> by induction on <span class="math inline">\(i\)</span>. For the base case, certainly <span class="math inline">\(S_0 \subseteq \LambdaTerms\)</span>. For the inductive step, suppose <span class="math inline">\(S_n \subseteq \LambdaTerms\)</span> for some <span class="math inline">\(n\)</span>. There are four ways a string <span class="math inline">\(s\)</span> can be in <span class="math inline">\(S_{n+1}\)</span>, and in each case we have <span class="math inline">\(s \in \LambdaTerms\)</span> using either the closure of <span class="math inline">\(\LambdaTerms\)</span> or the inductive hypothesis. So we have <span class="math inline">\(S_i \subseteq \LambdaTerms\)</span> for each <span class="math inline">\(i\)</span>, and thus <span class="math inline">\(\bigcup S_i \subseteq \LambdaTerms\)</span> as needed.</p>
<p>To see that <span class="math inline">\(\bigcup S_i \supseteq \LambdaTerms\)</span>, it suffices to show that <span class="math inline">\(\bigcup S_i\)</span> is closed; since <span class="math inline">\(\LambdaTerms\)</span> is the intersection over all closed sets the inclusion follows. To this end, note first that <span class="math inline">\(S_n \subseteq S_m\)</span> whenever <span class="math inline">\(n \leq m\)</span>. Now <span class="math display">\[\LambdaIdents \cup \LambdaConsts = S_0 \subseteq \bigcup S_i;\]</span> this handles the first two closure cases. We consider the remaining three in turn.</p>
<ol>
<li><p>Suppose <span class="math inline">\(x \in \LambdaIdents\)</span> and <span class="math inline">\(e \in \bigcup S_i\)</span>. Then we have <span class="math inline">\(e \in S_n\)</span> for some particular <span class="math inline">\(n\)</span>, and so <span class="math inline">\(\lamex{x}{e} \in S_{n+1} \subseteq \bigcup S_i\)</span> by definition.</p></li>
<li><p>Suppose <span class="math inline">\(x \in \LambdaTerms\)</span> and <span class="math inline">\(e_1, e_2 \in \bigcup S_i\)</span>; then we have <span class="math inline">\(e_1 \in S_{n_1}\)</span> and <span class="math inline">\(e_2 \in S_{n_2}\)</span> for some particular <span class="math inline">\(n_1\)</span> and <span class="math inline">\(n_2\)</span>. By definition, we have <span class="math display">\[\letin{x}{e_1}{e_2} \in S_{\max(n_1,n_2)} \subseteq \bigcup S_i\]</span> as needed.</p></li>
<li><p>Suppose <span class="math inline">\(e_1, e_2 \in \bigcup S_i\)</span>; then we have <span class="math inline">\(e_1 \in S_{n_1}\)</span> and <span class="math inline">\(e_2 \in S_{n_2}\)</span> for some particular <span class="math inline">\(n_1\)</span> and <span class="math inline">\(n_2\)</span>. By definition, we have <span class="math display">\[\apply{e_1}{e_2} \in S_{\max(n_1,n_2)} \subseteq \bigcup S_i\]</span> as needed.</p></li>
</ol>
<p>So <span class="math inline">\(\bigcup S_i\)</span> is closed, and thus <span class="math inline">\(\LambdaTerms \subseteq \bigcup S_i\)</span>. We then have <span class="math inline">\(\LambdaTerms = \bigcup S_i\)</span> as claimed.</p>
</div>
</div>
<p>The limit-based characterization of <span class="math inline">\(\LambdaTerms\)</span> suggests a natural way to "measure" its elements.</p>
<div class="definition">
<p>Let <span class="math inline">\(e \in \LambdaTerms\)</span>. Then there exists a <span class="math inline">\(k \in \nats\)</span> with <span class="math inline">\(e \in S_k\)</span>. The smallest such <span class="math inline">\(k\)</span> is called the <em>height</em> of <span class="math inline">\(e\)</span>, denoted <span class="math inline">\(\height(e)\)</span>.</p>
</div>
<p>We're using the well-ordering property of <span class="math inline">\(\nats\)</span> to define <span class="math inline">\(\height\)</span> here, which means this is a non-constructive definition. However we can characterize it using (terminating) recursion as in the following result.</p>
<div class="theorem">
<p>(Structure of <span class="math inline">\(\lambda\)</span>-terms.) If <span class="math inline">\(z \in \LambdaTerms\)</span> then one (and only one) of the following holds.</p>
<ol>
<li><span class="math inline">\(z \in \LambdaIdents\)</span>.</li>
<li><span class="math inline">\(z \in \LambdaConsts\)</span>.</li>
<li><span class="math inline">\(z = \lamex{x}{e}\)</span> where <span class="math inline">\(e \in \LambdaTerms\)</span> and <span class="math inline">\(\height(z) = 1 + \height(e)\)</span>.</li>
<li><span class="math inline">\(z = \letin{x}{e_1}{e_2}\)</span> where <span class="math inline">\(e_1,e_2 \in \LambdaTerms\)</span> and <span class="math inline">\(\height(z) = 1 + \max(\height(e_1), \height(e_2))\)</span>.</li>
<li><span class="math inline">\(z = \apply{e_1}{e_2}\)</span> where <span class="math inline">\(e_1,e_2 \in \LambdaTerms\)</span> and <span class="math inline">\(\height(z) = 1 + \max(\height(e_1), \height(e_2))\)</span>.</li>
</ol>
<div class="proof">
<p>Let <span class="math inline">\(z \in \LambdaTerms\)</span> and let <span class="math inline">\(\height(z) = k\)</span>. We consider two cases: either <span class="math inline">\(k = 0\)</span> or <span class="math inline">\(k = n+1\)</span> for some <span class="math inline">\(n\)</span>.</p>
<p>If <span class="math inline">\(k = 0\)</span>, then <span class="math inline">\(z \in S_0\)</span>, so by definition either <span class="math inline">\(z \in \LambdaIdents\)</span> or <span class="math inline">\(z \in \LambdaConsts\)</span> as needed.</p>
<p>Suppose instead that <span class="math inline">\(k = n+1\)</span> for some <span class="math inline">\(n\)</span>, so that <span class="math inline">\(z \in S_{n+1}\)</span>. Since <span class="math inline">\(k\)</span> is minimal with <span class="math inline">\(z \in S_k\)</span>, we have <span class="math inline">\(z \notin S_n\)</span>. Then there are three possibilities.</p>
<ol>
<li><p>Suppose <span class="math inline">\(z = \lamex{x}{e}\)</span> with <span class="math inline">\(e \in S_n\)</span>. If <span class="math inline">\(e \in S_i\)</span> for some <span class="math inline">\(i &lt; n\)</span> then we have <span class="math inline">\(z \in S_{i+1}\)</span>, violating the minimalness of <span class="math inline">\(n+1\)</span>. So in fact <span class="math inline">\(\height(e) = n\)</span> and we have <span class="math inline">\(\height(z) = 1 + \height(e)\)</span>.</p></li>
<li><p>Suppose <span class="math inline">\(z = \letin{x}{e_1}{e_2}\)</span> with <span class="math inline">\(e_1, e_2 \in S_n\)</span>. Set <span class="math inline">\(h_1 = \height(e_1)\)</span> and <span class="math inline">\(h_2 = \height(e_2)\)</span>. Note that <span class="math inline">\(h_1, h_2 \leq n\)</span>. If both of these inequalities are strict, say <span class="math inline">\(e_1, e_2 \in S_i\)</span> with <span class="math inline">\(i &lt; n\)</span>, then we have <span class="math inline">\(z \in S_{i+1}\)</span>, violating the minimalness of <span class="math inline">\(n+1\)</span>. So at least one of <span class="math inline">\(h_1\)</span> and <span class="math inline">\(h_2\)</span> is equal to <span class="math inline">\(n\)</span> and we have <span class="math inline">\(\height(z) = 1 + \max(\height(e_1),\height(e_2))\)</span>.</p></li>
<li><p>Suppose <span class="math inline">\(z = \apply{e_1}{e_2}\)</span> with <span class="math inline">\(e_1, e_2 \in S_n\)</span>. Set <span class="math inline">\(h_1 = \height(e_1)\)</span> and <span class="math inline">\(h_2 = \height(e_2)\)</span>. Note that <span class="math inline">\(h_1, h_2 \leq n\)</span>. If both of these inequalities are strict, say <span class="math inline">\(e_1, e_2 \in S_i\)</span> with <span class="math inline">\(i &lt; n\)</span>, then we have <span class="math inline">\(z \in S_{i+1}\)</span>, violating the minimalness of <span class="math inline">\(n+1\)</span>. So at least one of <span class="math inline">\(h_1\)</span> and <span class="math inline">\(h_2\)</span> is equal to <span class="math inline">\(n\)</span> and we have <span class="math inline">\(\height(z) = 1 + \max(\height(e_1),\height(e_2))\)</span>.</p></li>
</ol>
<p>The "and only one" part is trivial because each of the five forms starts with a different character; no string can match more than one.</p>
</div>
</div>
<p>There is an alternative notation we will sometimes prefer when expressing the five closure properties of <span class="math inline">\(\lambda\)</span>-terms: natural deduction style <em>inference rules</em>. These are the big fraction looking things we see so often in type theory literature.</p>
<div class="definition">
<p><a name='crossref-0'></a>(<span class="math inline">\(\lambda\)</span>-terms, natural deduction style.) We define <span class="math inline">\(\LambdaTerms\)</span> to be the smallest set satisfying the following rule schemas.</p>
<p><span class="math display">\[\begin{prooftree}
\AxiomC{$x \in \LambdaIdents$}
\RightLabel{$\mathsf{Var}_\lambda$}
\UnaryInfC{$x \in \LambdaTerms$}
\end{prooftree}\]</span></p>
<p><span class="math display">\[\begin{prooftree}
\AxiomC{$c \in \LambdaConsts$}
\RightLabel{$\mathsf{Con}_\lambda$}
\UnaryInfC{$c \in \LambdaTerms$}
\end{prooftree}\]</span></p>
<p><span class="math display">\[\begin{prooftree}
\AxiomC{$x \in \LambdaIdents$}
\AxiomC{$e \in \LambdaTerms$}
\RightLabel{$\mathsf{Abs}_\lambda$}
\BinaryInfC{$\lamex{x}{e} \in \LambdaTerms$}
\end{prooftree}\]</span></p>
<p><span class="math display">\[\begin{prooftree}
\AxiomC{$x \in \LambdaIdents$}
\AxiomC{$e_1 \in \LambdaTerms$}
\AxiomC{$e_2 \in \LambdaTerms$}
\RightLabel{$\mathsf{Let}_\lambda$}
\TrinaryInfC{$\letin{x}{e_1}{e_2} \in \LambdaTerms$}
\end{prooftree}\]</span></p>
<p><span class="math display">\[\begin{prooftree}
\AxiomC{$e_1 \in \LambdaTerms$}
\AxiomC{$e_2 \in \LambdaTerms$}
\RightLabel{$\mathsf{App}_\lambda$}
\BinaryInfC{$\apply{e_1}{e_2} \in \LambdaTerms$}
\end{prooftree}\]</span></p>
</div>
<p>Establishing that a particular string is in <span class="math inline">\(\LambdaTerms\)</span> requires evidence, and natural deduction style proof trees are a handy notation for this evidence. For instance, here is a tree establishing that the string <code>(x \c)</code> is a <span class="math inline">\(\lambda\)</span>-term.</p>
<p><span class="math display">\[\begin{prooftree}
\AxiomC{$x \in \LambdaIdents$}
\RightLabel{$\mathsf{Var}_\lambda$}
\UnaryInfC{$x \in \LambdaTerms$}
\AxiomC{$\backslash c \in \LambdaConsts$}
\RightLabel{$\mathsf{Con}_\lambda$}
\UnaryInfC{$\backslash c \in \LambdaTerms$}
\RightLabel{$\mathsf{App}_\lambda$}
\BinaryInfC{$\apply{x}{\backslash c} \in \LambdaTerms$}
\end{prooftree}\]</span></p>
<p>The structure theorem for <span class="math inline">\(\lambda\)</span>-terms justifies modeling <span class="math inline">\(\LambdaTerms\)</span> using the following Haskell type.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">data</span> <span class="dt">LambdaTerm</span> a</a>
<a class="sourceLine" id="cb2-2" title="2">  <span class="ot">=</span> <span class="dt">VariableTerm</span> a <span class="dt">LambdaVariable</span></a>
<a class="sourceLine" id="cb2-3" title="3">  <span class="op">|</span> <span class="dt">ConstantTerm</span> a <span class="dt">LambdaConstant</span></a>
<a class="sourceLine" id="cb2-4" title="4">  <span class="op">|</span> <span class="dt">Abstraction</span>  a (<span class="dt">LambdaVariable</span>, a) (<span class="dt">LambdaTerm</span> a)</a>
<a class="sourceLine" id="cb2-5" title="5">  <span class="op">|</span> <span class="dt">LetBinding</span>   a (<span class="dt">LambdaVariable</span>, a) (<span class="dt">LambdaTerm</span> a) (<span class="dt">LambdaTerm</span> a)</a>
<a class="sourceLine" id="cb2-6" title="6">  <span class="op">|</span> <span class="dt">Application</span>  a                     (<span class="dt">LambdaTerm</span> a) (<span class="dt">LambdaTerm</span> a)</a>
<a class="sourceLine" id="cb2-7" title="7">  <span class="kw">deriving</span> (<span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb2-8" title="8"></a>
<a class="sourceLine" id="cb2-9" title="9"><span class="kw">newtype</span> <span class="dt">LambdaVariable</span> <span class="ot">=</span> <span class="dt">LambdaVariable</span></a>
<a class="sourceLine" id="cb2-10" title="10">  {<span class="ot"> unLambdaVariable ::</span> <span class="dt">T.Text</span></a>
<a class="sourceLine" id="cb2-11" title="11">  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb2-12" title="12"></a>
<a class="sourceLine" id="cb2-13" title="13"><span class="kw">newtype</span> <span class="dt">LambdaConstant</span> <span class="ot">=</span> <span class="dt">LambdaConstant</span></a>
<a class="sourceLine" id="cb2-14" title="14">  {<span class="ot"> unLambdaConstant ::</span> <span class="dt">T.Text</span></a>
<a class="sourceLine" id="cb2-15" title="15">  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb2-16" title="16"></a>
<a class="sourceLine" id="cb2-17" title="17"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">LambdaTerm</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-18" title="18">  <span class="fu">fmap</span> f <span class="ot">=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb2-19" title="19">    <span class="dt">VariableTerm</span> a x            <span class="ot">-&gt;</span> <span class="dt">VariableTerm</span> (f a) x</a>
<a class="sourceLine" id="cb2-20" title="20">    <span class="dt">ConstantTerm</span> a c            <span class="ot">-&gt;</span> <span class="dt">ConstantTerm</span> (f a) c</a>
<a class="sourceLine" id="cb2-21" title="21">    <span class="dt">Abstraction</span>  a (x, b) e     <span class="ot">-&gt;</span> <span class="dt">Abstraction</span>  (f a) (x, f b) (<span class="fu">fmap</span> f e)</a>
<a class="sourceLine" id="cb2-22" title="22">    <span class="dt">LetBinding</span>   a (x, b) e1 e2 <span class="ot">-&gt;</span> <span class="dt">LetBinding</span>   (f a) (x, f b) (<span class="fu">fmap</span> f e1) (<span class="fu">fmap</span> f e2)</a>
<a class="sourceLine" id="cb2-23" title="23">    <span class="dt">Application</span>  a        e1 e2 <span class="ot">-&gt;</span> <span class="dt">Application</span>  (f a)          (<span class="fu">fmap</span> f e1) (<span class="fu">fmap</span> f e2)</a>
<a class="sourceLine" id="cb2-24" title="24"></a>
<a class="sourceLine" id="cb2-25" title="25"><span class="kw">instance</span> <span class="dt">Eq</span> (<span class="dt">LambdaTerm</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-26" title="26">  z1 <span class="op">==</span> z2 <span class="ot">=</span> <span class="kw">case</span> (z1,z2) <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-27" title="27">    (<span class="dt">VariableTerm</span> _ x1, <span class="dt">VariableTerm</span> _ x2) <span class="ot">-&gt;</span> x1 <span class="op">==</span> x2</a>
<a class="sourceLine" id="cb2-28" title="28">    (<span class="dt">ConstantTerm</span> _ c1, <span class="dt">ConstantTerm</span> _ c2) <span class="ot">-&gt;</span> c1 <span class="op">==</span> c2</a>
<a class="sourceLine" id="cb2-29" title="29">    (<span class="dt">Abstraction</span> _ (x1, _) e1, <span class="dt">Abstraction</span> _ (x2, _) e2) <span class="ot">-&gt;</span> x1 <span class="op">==</span> x2 <span class="op">&amp;&amp;</span> e1 <span class="op">==</span> e2</a>
<a class="sourceLine" id="cb2-30" title="30">    (<span class="dt">LetBinding</span> _ (x1, _) e1 f1, <span class="dt">LetBinding</span> _ (x2, _) e2 f2) <span class="ot">-&gt;</span> x1 <span class="op">==</span> x2 <span class="op">&amp;&amp;</span> e1 <span class="op">==</span> e2 <span class="op">&amp;&amp;</span> f1 <span class="op">==</span> f2</a>
<a class="sourceLine" id="cb2-31" title="31">    (<span class="dt">Application</span> _ e1 f1, <span class="dt">Application</span> _ e2 f2) <span class="ot">-&gt;</span> e1 <span class="op">==</span> e2 <span class="op">&amp;&amp;</span> f1 <span class="op">==</span> f2</a>
<a class="sourceLine" id="cb2-32" title="32">    _ <span class="ot">-&gt;</span> <span class="dt">False</span></a></code></pre></div>
<p>We've made one addition: these expressions are decorated with an extra value of type <code>a</code>. We'll use this later to include type annotations and source location information, but for now it can just be <code>()</code>. Annotations are ignored for the purpose of equality testing.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">class</span> <span class="dt">LambdaAnnotation</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="ot">  emptyLambdaAnnotation ::</span> a</a>
<a class="sourceLine" id="cb3-3" title="3"></a>
<a class="sourceLine" id="cb3-4" title="4"><span class="kw">instance</span> <span class="dt">LambdaAnnotation</span> () <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-5" title="5">  emptyLambdaAnnotation <span class="ot">=</span> ()</a>
<a class="sourceLine" id="cb3-6" title="6"></a>
<a class="sourceLine" id="cb3-7" title="7"><span class="ot">lambda ::</span> (<span class="dt">LambdaAnnotation</span> a) <span class="ot">=&gt;</span> <span class="dt">LambdaVariable</span> <span class="ot">-&gt;</span> <span class="dt">LambdaTerm</span> a <span class="ot">-&gt;</span> <span class="dt">LambdaTerm</span> a</a>
<a class="sourceLine" id="cb3-8" title="8">lambda x e <span class="ot">=</span> <span class="dt">Abstraction</span> emptyLambdaAnnotation (x, emptyLambdaAnnotation) e</a>
<a class="sourceLine" id="cb3-9" title="9"></a>
<a class="sourceLine" id="cb3-10" title="10"><span class="ot">letin ::</span> (<span class="dt">LambdaAnnotation</span> a) <span class="ot">=&gt;</span> <span class="dt">LambdaVariable</span> <span class="ot">-&gt;</span> <span class="dt">LambdaTerm</span> a <span class="ot">-&gt;</span> <span class="dt">LambdaTerm</span> a <span class="ot">-&gt;</span> <span class="dt">LambdaTerm</span> a</a>
<a class="sourceLine" id="cb3-11" title="11">letin x e1 e2 <span class="ot">=</span> <span class="dt">LetBinding</span> emptyLambdaAnnotation (x, emptyLambdaAnnotation) e1 e2</a></code></pre></div>
<p>Note that <code>LambdaTerm a</code> is not a set of strings! What we've done is encode the set of <em>valid derivations</em> of <span class="math inline">\(\lambda\)</span>-terms as a type; the structure of <code>LambdaTerm</code> is precisely the structure of a derivation that a given string is in <span class="math inline">\(\LambdaTerms\)</span>, at least when <code>a</code> is <code>()</code>.</p>
<p>Translating the <span class="math inline">\(\height\)</span> function from the theorem is straightforward.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="ot">heightOfLambdaTerm ::</span> <span class="dt">LambdaTerm</span> a <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb4-2" title="2">heightOfLambdaTerm <span class="ot">=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb4-3" title="3">  <span class="dt">VariableTerm</span> _ _       <span class="ot">-&gt;</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb4-4" title="4">  <span class="dt">ConstantTerm</span> _ _       <span class="ot">-&gt;</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb4-5" title="5">  <span class="dt">Abstraction</span>  _ _ e     <span class="ot">-&gt;</span> <span class="dv">1</span> <span class="op">+</span> heightOfLambdaTerm e</a>
<a class="sourceLine" id="cb4-6" title="6">  <span class="dt">LetBinding</span>   _ _ e1 e2 <span class="ot">-&gt;</span> <span class="dv">1</span> <span class="op">+</span> <span class="fu">max</span> (heightOfLambdaTerm e1) (heightOfLambdaTerm e2)</a>
<a class="sourceLine" id="cb4-7" title="7">  <span class="dt">Application</span>  _   e1 e2 <span class="ot">-&gt;</span> <span class="dv">1</span> <span class="op">+</span> <span class="fu">max</span> (heightOfLambdaTerm e1) (heightOfLambdaTerm e2)</a></code></pre></div>
<p>The structure theorem also justifies our use of recursive definitions of functions on <span class="math inline">\(\LambdaTerms\)</span>; we can define a function on <span class="math inline">\(\lambda\)</span>-terms by specifying it on variables and constants (the base case) and then for all other constructs in terms of its values on shorter terms (the recursive case). For example, we can use this to define the <em>size</em> of a term.</p>
<div class="definition">
<p>The <em>size</em> of a lambda term is defined recursively as follows.</p>
<ol>
<li>If <span class="math inline">\(x \in \LambdaIdents\)</span> then <span class="math inline">\(\size(x) = 0\)</span>.</li>
<li>If <span class="math inline">\(c \in \LambdaConsts\)</span> then <span class="math inline">\(\size(c) = 0\)</span>.</li>
<li><span class="math inline">\(\size(\lamex{x}{e}) = 1 + \size(e)\)</span>.</li>
<li><span class="math inline">\(\size(\letin{x}{e_1}{e_2}) = 1 + \size(e_1) + \size(e_2)\)</span>.</li>
<li><span class="math inline">\(\size(\apply{e_1}{e_2}) = 1 + \size(e_1) + \size(e_2)\)</span>.</li>
</ol>
</div>
<p>Recursive functions translate to the Haskell representation cleanly.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="ot">sizeOfLambdaTerm ::</span> <span class="dt">LambdaTerm</span> a <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb5-2" title="2">sizeOfLambdaTerm <span class="ot">=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb5-3" title="3">  <span class="dt">VariableTerm</span> _ _       <span class="ot">-&gt;</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb5-4" title="4">  <span class="dt">ConstantTerm</span> _ _       <span class="ot">-&gt;</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb5-5" title="5">  <span class="dt">Abstraction</span>  _ _ e     <span class="ot">-&gt;</span> <span class="dv">1</span> <span class="op">+</span> sizeOfLambdaTerm e</a>
<a class="sourceLine" id="cb5-6" title="6">  <span class="dt">LetBinding</span>   _ _ e1 e2 <span class="ot">-&gt;</span> <span class="dv">1</span> <span class="op">+</span> sizeOfLambdaTerm e1 <span class="op">+</span> sizeOfLambdaTerm e2</a>
<a class="sourceLine" id="cb5-7" title="7">  <span class="dt">Application</span>  _   e1 e2 <span class="ot">-&gt;</span> <span class="dv">1</span> <span class="op">+</span> sizeOfLambdaTerm e1 <span class="op">+</span> sizeOfLambdaTerm e2</a></code></pre></div>
<p>We can also use recursion as a proof strategy. For example, the height of a <span class="math inline">\(\lambda\)</span>-term is bounded by its size. (The main value of this theorem is in demonstrating the structure of an inductive proof on <span class="math inline">\(\lambda\)</span>-terms.)</p>
<div class="theorem">
<p>For every <span class="math inline">\(\lambda\)</span>-term <span class="math inline">\(z\)</span> we have <span class="math inline">\(\height(z) \leq \size(z)\)</span>.</p>
<div class="proof">
<p>We proceed by structural induction on <span class="math inline">\(z\)</span>.</p>
<ol>
<li><p>If <span class="math inline">\(z \in \LambdaIdents\)</span> we have <span class="math inline">\(\height(z) = 0 = \size(z)\)</span> as needed.</p></li>
<li><p>If <span class="math inline">\(z \in \LambdaConsts\)</span> we have <span class="math inline">\(\height(z) = 0 = \size(z)\)</span> as needed.</p></li>
<li><p>Suppose <span class="math inline">\(z = \lamex{x}{e}\)</span>. By the induction hypothesis we have <span class="math inline">\(\height(e) \leq \size(e)\)</span>, so that <span class="math display">\[\height(z) = 1 + \height(e) \leq 1 + \size(e) = \size(z)\]</span> as needed.</p></li>
<li><p>Suppose <span class="math inline">\(z = \letin{x}{e_1}{e_2}\)</span>. By the induction hypothesis we have <span class="math inline">\(\height(e_1) \leq \size(e_1)\)</span> and <span class="math inline">\(\height(e_2) \leq \size(e_2)\)</span>. Now <span class="math display">\[\begin{eqnarray*}
 &amp;      &amp; \height(z) \\
 &amp; =    &amp; 1 + \max(\height(e_1),\height(e_2)) \\
 &amp; \leq &amp; 1 + \height(e_1) + \height(e_2) \\
 &amp; \leq &amp; 1 + \size(e_1) + \size(e_2) \\
 &amp; =    &amp; \size(z)
\end{eqnarray*}\]</span> as needed.</p></li>
<li>Suppose <span class="math inline">\(z = \apply{e_1}{e_2}\)</span>. By the induction hypothesis we have <span class="math inline">\(\height(e_1) \leq \size(e_1)\)</span> and <span class="math inline">\(\height(e_1) \leq \size(e_2)\)</span>. Now <span class="math display">\[\begin{eqnarray*}
 &amp;      &amp; \height(z) \\
 &amp; =    &amp; 1 + \max(\height(e_1),\height(e_2)) \\
 &amp; \leq &amp; 1 + \height(e_1) + \height(e_2) \\
 &amp; \leq &amp; 1 + \size(e_1) + \size(e_2) \\
 &amp; =    &amp; \size(z)
\end{eqnarray*}\]</span> as needed.</li>
</ol>
</div>
</div>
<p>Theorems are a natural source of property tests for our code; these are tests that hammer a function with random inputs and verify that some specified property always holds.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1">prop_heightOfLambdaTerm_lt_sizeOfLambdaTerm</a>
<a class="sourceLine" id="cb6-2" title="2"><span class="ot">  ::</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">LambdaTerm</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb6-3" title="3">prop_heightOfLambdaTerm_lt_sizeOfLambdaTerm e <span class="ot">=</span></a>
<a class="sourceLine" id="cb6-4" title="4">  heightOfLambdaTerm e <span class="op">&lt;=</span> sizeOfLambdaTerm e</a></code></pre></div>
<p>Property tests serve as a good check that (1) the proof of the theorem and (2) the translation into Haskell are correct (or at least not incorrect). We'll try to include them whenever possible; they are devastatingly effective at finding bugs. To use them, we'll need to be able to generate arbitrary values of type <code>LambdaTerm a</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">instance</span> (<span class="dt">Arbitrary</span> a) <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (<span class="dt">LambdaTerm</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" title="2">  arbitrary <span class="ot">=</span> getSize <span class="op">&gt;&gt;=</span> generateDepth</a>
<a class="sourceLine" id="cb7-3" title="3">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="ot">      generateDepth ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> (<span class="dt">LambdaTerm</span> a)</a>
<a class="sourceLine" id="cb7-5" title="5">      generateDepth k</a>
<a class="sourceLine" id="cb7-6" title="6">        <span class="op">|</span> k <span class="op">&lt;=</span> <span class="dv">0</span> <span class="ot">=</span> oneof</a>
<a class="sourceLine" id="cb7-7" title="7">            [ <span class="dt">VariableTerm</span> <span class="op">&lt;$&gt;</span> arbitrary <span class="op">&lt;*&gt;</span> arbitrary</a>
<a class="sourceLine" id="cb7-8" title="8">            , <span class="dt">ConstantTerm</span> <span class="op">&lt;$&gt;</span> arbitrary <span class="op">&lt;*&gt;</span> arbitrary</a>
<a class="sourceLine" id="cb7-9" title="9">            ]</a>
<a class="sourceLine" id="cb7-10" title="10">        <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-11" title="11">            <span class="kw">let</span> recur <span class="ot">=</span> elements [<span class="dv">0</span><span class="op">..</span>(k <span class="ot">`div`</span> <span class="dv">2</span>)] <span class="op">&gt;&gt;=</span> generateDepth</a>
<a class="sourceLine" id="cb7-12" title="12">            oneof</a>
<a class="sourceLine" id="cb7-13" title="13">              [ <span class="dt">Abstraction</span> <span class="op">&lt;$&gt;</span> arbitrary <span class="op">&lt;*&gt;</span> arbitrary <span class="op">&lt;*&gt;</span> recur</a>
<a class="sourceLine" id="cb7-14" title="14">              , <span class="dt">LetBinding</span>  <span class="op">&lt;$&gt;</span> arbitrary <span class="op">&lt;*&gt;</span> arbitrary <span class="op">&lt;*&gt;</span> recur <span class="op">&lt;*&gt;</span> recur</a>
<a class="sourceLine" id="cb7-15" title="15">              , <span class="dt">Application</span> <span class="op">&lt;$&gt;</span> arbitrary <span class="op">&lt;*&gt;</span>               recur <span class="op">&lt;*&gt;</span> recur</a>
<a class="sourceLine" id="cb7-16" title="16">              ]</a>
<a class="sourceLine" id="cb7-17" title="17"></a>
<a class="sourceLine" id="cb7-18" title="18">  shrink <span class="ot">=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb7-19" title="19">    <span class="dt">ConstantTerm</span> loc c <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb7-20" title="20">      <span class="fu">map</span> (<span class="dt">ConstantTerm</span> loc) <span class="op">$</span> shrink c</a>
<a class="sourceLine" id="cb7-21" title="21">    <span class="dt">VariableTerm</span> loc v <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb7-22" title="22">      <span class="fu">map</span> (<span class="dt">VariableTerm</span> loc) <span class="op">$</span> shrink v</a>
<a class="sourceLine" id="cb7-23" title="23">    <span class="dt">Abstraction</span> loc x e <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb7-24" title="24">      (e<span class="op">:</span>) <span class="op">$</span> <span class="fu">map</span> (<span class="dt">Abstraction</span> loc x) <span class="op">$</span> shrink e</a>
<a class="sourceLine" id="cb7-25" title="25">    <span class="dt">LetBinding</span> loc x e1 e2 <span class="ot">-&gt;</span> <span class="fu">concat</span></a>
<a class="sourceLine" id="cb7-26" title="26">      [ [ e1, e2 ]</a>
<a class="sourceLine" id="cb7-27" title="27">      , [ <span class="dt">LetBinding</span> loc x f1 e2 <span class="op">|</span> f1 <span class="ot">&lt;-</span> shrink e1 ]</a>
<a class="sourceLine" id="cb7-28" title="28">      , [ <span class="dt">LetBinding</span> loc x e1 f2 <span class="op">|</span> f2 <span class="ot">&lt;-</span> shrink e2 ]</a>
<a class="sourceLine" id="cb7-29" title="29">      ]</a>
<a class="sourceLine" id="cb7-30" title="30">    <span class="dt">Application</span> loc e1 e2 <span class="ot">-&gt;</span> <span class="fu">concat</span></a>
<a class="sourceLine" id="cb7-31" title="31">      [ [ e1, e2 ]</a>
<a class="sourceLine" id="cb7-32" title="32">      , [ <span class="dt">Application</span> loc f1 e2 <span class="op">|</span> f1 <span class="ot">&lt;-</span> shrink e1 ]</a>
<a class="sourceLine" id="cb7-33" title="33">      , [ <span class="dt">Application</span> loc e1 f2 <span class="op">|</span> f2 <span class="ot">&lt;-</span> shrink e2 ]</a>
<a class="sourceLine" id="cb7-34" title="34">      ]</a>
<a class="sourceLine" id="cb7-35" title="35"></a>
<a class="sourceLine" id="cb7-36" title="36"><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">LambdaVariable</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-37" title="37">  arbitrary <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-38" title="38">    <span class="kw">let</span></a>
<a class="sourceLine" id="cb7-39" title="39">      xs <span class="ot">=</span> <span class="st">&quot;xyzw&quot;</span></a>
<a class="sourceLine" id="cb7-40" title="40"></a>
<a class="sourceLine" id="cb7-41" title="41"><span class="ot">      ident ::</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> <span class="dt">Gen</span> <span class="dt">T.Text</span></a>
<a class="sourceLine" id="cb7-42" title="42">      ident as <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-43" title="43">        c <span class="ot">&lt;-</span> elements as</a>
<a class="sourceLine" id="cb7-44" title="44">        <span class="dt">NonNegative</span> k <span class="ot">&lt;- arbitrary ::</span> <span class="dt">Gen</span> (<span class="dt">NonNegative</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb7-45" title="45">        p <span class="ot">&lt;-</span> arbitrary</a>
<a class="sourceLine" id="cb7-46" title="46">        <span class="fu">return</span> <span class="op">$</span> T.pack <span class="op">$</span> <span class="kw">if</span> p</a>
<a class="sourceLine" id="cb7-47" title="47">          <span class="kw">then</span> [c]</a>
<a class="sourceLine" id="cb7-48" title="48">          <span class="kw">else</span> [c] <span class="op">&lt;&gt;</span> <span class="fu">show</span> k</a>
<a class="sourceLine" id="cb7-49" title="49"></a>
<a class="sourceLine" id="cb7-50" title="50">    <span class="dt">LambdaVariable</span> <span class="op">&lt;$&gt;</span> ident xs</a>
<a class="sourceLine" id="cb7-51" title="51"></a>
<a class="sourceLine" id="cb7-52" title="52">  shrink (<span class="dt">LambdaVariable</span> x) <span class="ot">=</span></a>
<a class="sourceLine" id="cb7-53" title="53">    <span class="kw">case</span> T.unpack x <span class="kw">of</span></a>
<a class="sourceLine" id="cb7-54" title="54">      []   <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb7-55" title="55">      c<span class="op">:</span>[] <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb7-56" title="56">      c<span class="op">:</span>cs <span class="ot">-&gt;</span> <span class="fu">map</span> (<span class="dt">LambdaVariable</span> <span class="op">.</span> T.pack <span class="op">.</span> (c<span class="op">:</span>)) <span class="op">$</span> shrink cs</a>
<a class="sourceLine" id="cb7-57" title="57"></a>
<a class="sourceLine" id="cb7-58" title="58"><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">LambdaConstant</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-59" title="59">  arbitrary <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-60" title="60">    <span class="kw">let</span></a>
<a class="sourceLine" id="cb7-61" title="61">      cs <span class="ot">=</span> <span class="st">&quot;abcd&quot;</span></a>
<a class="sourceLine" id="cb7-62" title="62"></a>
<a class="sourceLine" id="cb7-63" title="63"><span class="ot">      ident ::</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> <span class="dt">Gen</span> <span class="dt">T.Text</span></a>
<a class="sourceLine" id="cb7-64" title="64">      ident as <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-65" title="65">        c <span class="ot">&lt;-</span> elements as</a>
<a class="sourceLine" id="cb7-66" title="66">        <span class="dt">NonNegative</span> k <span class="ot">&lt;- arbitrary ::</span> <span class="dt">Gen</span> (<span class="dt">NonNegative</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb7-67" title="67">        p <span class="ot">&lt;-</span> arbitrary</a>
<a class="sourceLine" id="cb7-68" title="68">        <span class="fu">return</span> <span class="op">$</span> T.pack <span class="op">$</span> <span class="kw">if</span> p</a>
<a class="sourceLine" id="cb7-69" title="69">          <span class="kw">then</span> [c]</a>
<a class="sourceLine" id="cb7-70" title="70">          <span class="kw">else</span> [c] <span class="op">&lt;&gt;</span> <span class="fu">show</span> k</a>
<a class="sourceLine" id="cb7-71" title="71"></a>
<a class="sourceLine" id="cb7-72" title="72">    <span class="dt">LambdaConstant</span> <span class="op">&lt;$&gt;</span> ident cs</a>
<a class="sourceLine" id="cb7-73" title="73"></a>
<a class="sourceLine" id="cb7-74" title="74">  shrink (<span class="dt">LambdaConstant</span> x) <span class="ot">=</span></a>
<a class="sourceLine" id="cb7-75" title="75">    <span class="kw">case</span> T.unpack x <span class="kw">of</span></a>
<a class="sourceLine" id="cb7-76" title="76">      []   <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb7-77" title="77">      c<span class="op">:</span>[] <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb7-78" title="78">      c<span class="op">:</span>cs <span class="ot">-&gt;</span> <span class="fu">map</span> (<span class="dt">LambdaConstant</span> <span class="op">.</span> T.pack <span class="op">.</span> (c<span class="op">:</span>)) <span class="op">$</span> shrink cs</a></code></pre></div>
<p>We need a few more definitions before we can state and prove more interesting things about <span class="math inline">\(\lambda\)</span>-terms.</p>
</section>
<section class="level2">
<h2>Free and Bound Variables</h2>
<p>Note that in the <span class="math inline">\(\lambda\)</span> <a href="LambdaTerm.html#crossref-0">construction rules</a>, variables can be introduced in two fundamentally different ways. In <span class="math inline">\(\mathsf{Var}_\lambda\)</span>, variables are themselves terms. In <span class="math inline">\(\mathsf{Abs}_\lambda\)</span> and <span class="math inline">\(\mathsf{Let}_\lambda\)</span>, however, the variable is not a term on its own. In these latter two cases we say the variable appearance is a <em>binding site</em>. Then given a <span class="math inline">\(\lambda\)</span> term of the form <span class="math inline">\(\lamex{x}{e}\)</span> or <span class="math inline">\(\letin{x}{f}{e}\)</span>, any occurrence of <span class="math inline">\(x\)</span> in <span class="math inline">\(e\)</span> is <em>bound</em> -- although not necessarily at that binding site, if there is a deeper binding of <span class="math inline">\(x\)</span> that shadows the outer binding.</p>
<p>If a variable in a <span class="math inline">\(\lambda\)</span>-term is not bound, it is <em>free</em>. We can formalize the set of free variables in a term with a recursive function.</p>
<div class="definition">
<p>The set of <em>free variables</em> in a <span class="math inline">\(\lambda\)</span>-term <span class="math inline">\(z\)</span>, denoted <span class="math inline">\(\freeLambdaVars(z)\)</span>, is defined recursively as follows.</p>
<ol>
<li>If <span class="math inline">\(x \in \LambdaIdents\)</span> then <span class="math inline">\(\freeLambdaVars(x) = \{x\}\)</span>.</li>
<li>If <span class="math inline">\(c \in \LambdaConsts\)</span> then <span class="math inline">\(\freeLambdaVars(c) = \varnothing\)</span>.</li>
<li><span class="math inline">\(\freeLambdaVars(\lamex{x}{e}) = \freeLambdaVars(e) \setminus \{x\}\)</span>.</li>
<li><span class="math inline">\(\freeLambdaVars(\letin{x}{e_1}{e_2}) = \freeLambdaVars(e_1) \cup (\freeLambdaVars(e_2) \setminus \{x\})\)</span>.</li>
<li><span class="math inline">\(\freeLambdaVars(\apply{e_1}{e_2}) = \freeLambdaVars(e_1) \cup \freeLambdaVars(e_2)\)</span>.</li>
</ol>
</div>
<p>As usual, the translation to Haskell is straightforward.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1">freeLambdaVariablesInLambdaTerm</a>
<a class="sourceLine" id="cb8-2" title="2"><span class="ot">  ::</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">LambdaTerm</span> a <span class="ot">-&gt;</span> <span class="dt">S.Set</span> <span class="dt">LambdaVariable</span></a>
<a class="sourceLine" id="cb8-3" title="3">freeLambdaVariablesInLambdaTerm <span class="ot">=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb8-4" title="4">  <span class="dt">VariableTerm</span> _ x <span class="ot">-&gt;</span> S.singleton x</a>
<a class="sourceLine" id="cb8-5" title="5">  <span class="dt">ConstantTerm</span> _ _ <span class="ot">-&gt;</span> S.empty</a>
<a class="sourceLine" id="cb8-6" title="6">  <span class="dt">Abstraction</span> _ (x, _) e <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-7" title="7">    S.delete x <span class="op">$</span> freeLambdaVariablesInLambdaTerm e</a>
<a class="sourceLine" id="cb8-8" title="8">  <span class="dt">LetBinding</span> _ (x, _) e1 e2 <span class="ot">-&gt;</span> S.union</a>
<a class="sourceLine" id="cb8-9" title="9">    (freeLambdaVariablesInLambdaTerm e1)</a>
<a class="sourceLine" id="cb8-10" title="10">    (S.delete x <span class="op">$</span> freeLambdaVariablesInLambdaTerm e2)</a>
<a class="sourceLine" id="cb8-11" title="11">  <span class="dt">Application</span> _ e1 e2 <span class="ot">-&gt;</span> S.union</a>
<a class="sourceLine" id="cb8-12" title="12">    (freeLambdaVariablesInLambdaTerm e1)</a>
<a class="sourceLine" id="cb8-13" title="13">    (freeLambdaVariablesInLambdaTerm e2)</a></code></pre></div>
<p>It's worth stating that any given <span class="math inline">\(\lambda\)</span>-term has finitely many free variables, because then <span class="math inline">\(\LambdaIdents \setminus \freeLambdaVars(z)\)</span> is always nonempty.</p>
<div class="lemma">
<p>For any <span class="math inline">\(\lambda\)</span>-term <span class="math inline">\(z\)</span>, <span class="math inline">\(\freeLambdaVars(z)\)</span> is finite.</p>
<div class="proof">
<p>By structural induction on <span class="math inline">\(\lambda\)</span>-terms. The empty set and singleton sets are finite, subsets of a finite set are finite, and the pairwise union of finite sets is finite.</p>
</div>
</div>
<p>We'll also assume the existence of a distinguished function <span class="math inline">\(\choice : \mathcal{P}(\LambdaIdents) \setminus \varnothing \rightarrow \LambdaIdents\)</span> which selects an element from a nonempty set of variables. We can avoid using the axiom of choice here by assuming an ordering on variables and taking the smallest one. This ordering doesn't have to be the obvious one, either; for example, consider the graded ordering that considers <span class="math inline">\(\mathsf{x0}, \mathsf{x1}, \ldots\)</span> to be smaller than all other identifiers, and then compares using the ordinary lexicographic order. Then if <span class="math inline">\(A\)</span> is not finite then <span class="math inline">\(\choice(A)\)</span> will be of the form <span class="math inline">\(\mathsf{x}n\)</span> for some <span class="math inline">\(n \in \nats\)</span>. (This is useful for our implementation of <span class="math inline">\(\choice\)</span>.)</p>
<p>The free variables in a <span class="math inline">\(\lambda\)</span>-expression are subject to substitution.</p>
<div class="definition">
<p>Functions <span class="math inline">\(\LambdaIdents \rightarrow \LambdaTerms\)</span> are called <em>substitutions</em>. Given an identifier <span class="math inline">\(x\)</span>, a <span class="math inline">\(\lambda\)</span>-term <span class="math inline">\(z\)</span>, and a substitution <span class="math inline">\(\sigma\)</span>, we define a set <span class="math inline">\(\new(x,z,\sigma)\)</span> by <span class="math display">\[\new(x,z,\sigma) = \{ y \in \LambdaIdents \mid \mathrm{if}\ u \in \freeLambdaVars(z) \setminus \{x\}\ \mathrm{then}\ y \notin \freeLambdaVars(\sigma(u)) \}.\]</span></p>
<p>We also define a <em>pointwise update</em> operation. Given <span class="math inline">\(\sigma\)</span>, we define <span class="math inline">\(\sigma_{v/u}\)</span> by <span class="math display">\[\sigma_{v/u}(x) = \left\{\begin{array}{ll} v &amp; \mathrm{if}\ x = u \\ \sigma(x) &amp; \mathrm{otherwise}. \end{array}\right.\]</span></p>
<p>The set of all substitutions is denoted <span class="math inline">\(\LambdaSubstitutions\)</span>.</p>
</div>
<p>That is, <span class="math inline">\(\new(x,z,\sigma)\)</span> consists of those variables which are not free in any <span class="math inline">\(\sigma(u)\)</span> where <span class="math inline">\(u\)</span> ranges over the free variables in <span class="math inline">\(z\)</span>, except for <span class="math inline">\(x\)</span>. The set of variables <span class="math inline">\(y\)</span> <em>can't</em> be is finite, so <span class="math inline">\(\new(x,z,\sigma)\)</span> is always infinite (in particular, it's not empty.)</p>
<p>Substitutions are defined as functions from variables to terms, but in practice they will be the identity on all but a finite number of inputs. For this reason we can implement them as finite maps and decree that such a map is the identity outside of its explicit domain. This is important for our implementation.</p>
<p>We'd like to implement <span class="math inline">\(\new\)</span> in code, however this is awkward because the value of <span class="math inline">\(\new(x,z,\sigma)\)</span> is an infinite set. Instead we'll implement <span class="math inline">\(\new\)</span> as a predicate on variables; <code>isNewLambdaVar x z sigma y</code> will return <code>True</code> precisely when <span class="math inline">\(y \in \new(x,z,\sigma)\)</span>. Then we can implement <span class="math inline">\(\choice(\new(x,z,\sigma))\)</span> by taking the first identifier <span class="math inline">\(\mathsf{x}n\)</span> which satisfies the predicate.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1">isNewLambdaVar</a>
<a class="sourceLine" id="cb9-2" title="2"><span class="ot">  ::</span> <span class="dt">LambdaVariable</span> <span class="ot">-&gt;</span> <span class="dt">LambdaTerm</span> a <span class="ot">-&gt;</span> <span class="dt">M.Map</span> <span class="dt">LambdaVariable</span> (<span class="dt">LambdaTerm</span> a)</a>
<a class="sourceLine" id="cb9-3" title="3">  <span class="ot">-&gt;</span> <span class="dt">LambdaVariable</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb9-4" title="4">isNewLambdaVar x z sigma y <span class="ot">=</span></a>
<a class="sourceLine" id="cb9-5" title="5">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb9-6" title="6">    <span class="co">-- M.Map values are finite, so we implicitly</span></a>
<a class="sourceLine" id="cb9-7" title="7">    <span class="co">-- make sigma the identity outside of its support</span></a>
<a class="sourceLine" id="cb9-8" title="8">    freeImageOf u <span class="ot">=</span> <span class="kw">case</span> M.lookup u sigma <span class="kw">of</span></a>
<a class="sourceLine" id="cb9-9" title="9">      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> S.singleton u</a>
<a class="sourceLine" id="cb9-10" title="10">      <span class="dt">Just</span> e  <span class="ot">-&gt;</span> freeLambdaVariablesInLambdaTerm e</a>
<a class="sourceLine" id="cb9-11" title="11">  <span class="kw">in</span> <span class="fu">all</span></a>
<a class="sourceLine" id="cb9-12" title="12">    (\u <span class="ot">-&gt;</span> S.notMember y <span class="op">$</span> freeImageOf u)</a>
<a class="sourceLine" id="cb9-13" title="13">    (S.delete x <span class="op">$</span> freeLambdaVariablesInLambdaTerm z)</a>
<a class="sourceLine" id="cb9-14" title="14"></a>
<a class="sourceLine" id="cb9-15" title="15">chooseNewLambdaVar</a>
<a class="sourceLine" id="cb9-16" title="16"><span class="ot">  ::</span> <span class="dt">LambdaVariable</span> <span class="ot">-&gt;</span> <span class="dt">LambdaTerm</span> a <span class="ot">-&gt;</span> <span class="dt">M.Map</span> <span class="dt">LambdaVariable</span> (<span class="dt">LambdaTerm</span> a) <span class="ot">-&gt;</span> <span class="dt">LambdaVariable</span></a>
<a class="sourceLine" id="cb9-17" title="17">chooseNewLambdaVar x z sigma <span class="ot">=</span> <span class="fu">head</span></a>
<a class="sourceLine" id="cb9-18" title="18">  <span class="op">$</span> <span class="fu">filter</span> (isNewLambdaVar x z sigma)</a>
<a class="sourceLine" id="cb9-19" title="19">  <span class="op">$</span> <span class="fu">map</span> (\k <span class="ot">-&gt;</span> <span class="dt">LambdaVariable</span> <span class="op">$</span> T.pack (<span class="st">&quot;x&quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> k))</a>
<a class="sourceLine" id="cb9-20" title="20">  <span class="op">$</span> [<span class="dv">0</span><span class="op">..</span>]</a></code></pre></div>
<p>We can also implement the pointwise update operator.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1">variableUpdateSub</a>
<a class="sourceLine" id="cb10-2" title="2"><span class="ot">  ::</span> (<span class="dt">LambdaAnnotation</span> a)</a>
<a class="sourceLine" id="cb10-3" title="3">  <span class="ot">=&gt;</span> <span class="dt">LambdaVariable</span> <span class="ot">-&gt;</span> <span class="dt">LambdaVariable</span></a>
<a class="sourceLine" id="cb10-4" title="4">  <span class="ot">-&gt;</span> <span class="dt">M.Map</span> <span class="dt">LambdaVariable</span> (<span class="dt">LambdaTerm</span> a) <span class="ot">-&gt;</span> <span class="dt">M.Map</span> <span class="dt">LambdaVariable</span> (<span class="dt">LambdaTerm</span> a)</a>
<a class="sourceLine" id="cb10-5" title="5">variableUpdateSub y x <span class="ot">=</span> M.insert x (<span class="dt">VariableTerm</span> emptyLambdaAnnotation y)</a></code></pre></div>
<p>We're now prepared to define substitution of variables.</p>
<div class="definition">
<p>Let <span class="math inline">\(z\)</span> be a <span class="math inline">\(\lambda\)</span>-term and <span class="math inline">\(\sigma\)</span> a substitution. The <em>simultaneous substitution</em> of <span class="math inline">\(\sigma\)</span> on <span class="math inline">\(z\)</span>, denoted <span class="math inline">\(\sigma[z]\)</span>, yields a new <span class="math inline">\(\lambda\)</span>-term, defined by structural recursion as follows.</p>
<ol>
<li>If <span class="math inline">\(z \in \LambdaIdents\)</span> then <span class="math inline">\(\sigma[z] = \sigma(z)\)</span>.</li>
<li>If <span class="math inline">\(z \in \LambdaConsts\)</span> then <span class="math inline">\(\sigma[z] = z\)</span>.</li>
<li>If <span class="math inline">\(z = \lamex{x}{e}\)</span> then <span class="math inline">\(\sigma[z] = \lamex{y}{\sigma_{y/x}[e]}\)</span> where <span class="math inline">\(y = \choice(\new(x,e,\sigma))\)</span>.</li>
<li>If <span class="math inline">\(z = \letin{x}{e_1}{e_2}\)</span> then <span class="math inline">\(\sigma[z] = \letin{y}{\sigma[e_1]}{\sigma_{y/x}[e_2]}\)</span> where <span class="math inline">\(y = \choice(\new(x,e_2,\sigma))\)</span>.</li>
<li>If <span class="math inline">\(z = \apply{e_1}{e_2}\)</span> then <span class="math inline">\(\sigma[z] = \apply{\sigma[e_1]}{\sigma[e_2]}\)</span>.</li>
</ol>
</div>
<p>The Haskell translation is straightforward. Also note that as a consequence of modeling substitutions using finite maps, we can model the identity substitution <span class="math inline">\(\mathsf{id}\)</span> using the empty <code>Map</code>.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1">applySubToLambdaTerm</a>
<a class="sourceLine" id="cb11-2" title="2"><span class="ot">  ::</span> <span class="dt">M.Map</span> <span class="dt">LambdaVariable</span> (<span class="dt">LambdaTerm</span> a) <span class="ot">-&gt;</span> <span class="dt">LambdaTerm</span> a <span class="ot">-&gt;</span> <span class="dt">LambdaTerm</span> a</a>
<a class="sourceLine" id="cb11-3" title="3">applySubToLambdaTerm sigma <span class="ot">=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb11-4" title="4">  <span class="dt">VariableTerm</span> a x <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb11-5" title="5">    M.findWithDefault (<span class="dt">VariableTerm</span> a x) x sigma</a>
<a class="sourceLine" id="cb11-6" title="6">  <span class="dt">ConstantTerm</span> a c <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb11-7" title="7">    <span class="dt">ConstantTerm</span> a c</a>
<a class="sourceLine" id="cb11-8" title="8">  <span class="dt">Abstraction</span> a (x, b) e <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb11-9" title="9">    <span class="kw">let</span> y <span class="ot">=</span> chooseNewLambdaVar x e sigma</a>
<a class="sourceLine" id="cb11-10" title="10">    <span class="kw">in</span> <span class="dt">Abstraction</span> a (y, b)</a>
<a class="sourceLine" id="cb11-11" title="11">      (applySubToLambdaTerm (M.insert x (<span class="dt">VariableTerm</span> b y) sigma) e)</a>
<a class="sourceLine" id="cb11-12" title="12">  <span class="dt">LetBinding</span> a (x, b) e1 e2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb11-13" title="13">    <span class="kw">let</span> y <span class="ot">=</span> chooseNewLambdaVar x e2 sigma</a>
<a class="sourceLine" id="cb11-14" title="14">    <span class="kw">in</span> <span class="dt">LetBinding</span> a (y, b)</a>
<a class="sourceLine" id="cb11-15" title="15">      (applySubToLambdaTerm sigma e1)</a>
<a class="sourceLine" id="cb11-16" title="16">      (applySubToLambdaTerm (M.insert x (<span class="dt">VariableTerm</span> b y) sigma) e2)</a>
<a class="sourceLine" id="cb11-17" title="17">  <span class="dt">Application</span> a e1 e2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb11-18" title="18">    <span class="dt">Application</span> a</a>
<a class="sourceLine" id="cb11-19" title="19">      (applySubToLambdaTerm sigma e1)</a>
<a class="sourceLine" id="cb11-20" title="20">      (applySubToLambdaTerm sigma e2)</a>
<a class="sourceLine" id="cb11-21" title="21"></a>
<a class="sourceLine" id="cb11-22" title="22"><span class="ot">identitySub ::</span> <span class="dt">M.Map</span> <span class="dt">LambdaVariable</span> (<span class="dt">LambdaTerm</span> a)</a>
<a class="sourceLine" id="cb11-23" title="23">identitySub <span class="ot">=</span> M.empty</a></code></pre></div>
<p>At this point we can prove some basic facts about free variables of substitutions. First, we can characterize the free variables in an applied substitution.</p>
<div class="theorem">
<p><a name='crossref-1'></a>(Free variables in an applied substitution.) Let <span class="math inline">\(z\)</span> be a <span class="math inline">\(\lambda\)</span>-term and <span class="math inline">\(\sigma\)</span> a substitution. Then we have <span class="math display">\[\freeLambdaVars(\sigma[z]) = \bigcup_{t \in \freeLambdaVars(z)} \freeLambdaVars(\sigma(t)).\]</span></p>
<div class="proof">
<p>We proceed by structural induction on <span class="math inline">\(z\)</span>.</p>
<ol>
<li><p>If <span class="math inline">\(z \in \LambdaIdents\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \freeLambdaVars(\sigma[z]) \\
 &amp; = &amp; \freeLambdaVars(\sigma(z)) \\
 &amp; = &amp; \bigcup_{t \in \{z\}} \freeLambdaVars(\sigma(t)) \\
 &amp; = &amp; \bigcup_{t \in \freeLambdaVars(z)} \freeLambdaVars(\sigma(t))
\end{eqnarray*}\]</span> as claimed.</p></li>
<li><p>If <span class="math inline">\(z \in \LambdaConsts\)</span>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \freeLambdaVars(\sigma[z]) \\
 &amp; = &amp; \freeLambdaVars(z) \\
 &amp; = &amp; \varnothing \\
 &amp; = &amp; \bigcup_{t \in \varnothing} \freeLambdaVars(\sigma(t)) \\
 &amp; = &amp; \bigcup_{t \in \freeLambdaVars(z)} \freeLambdaVars(\sigma(t))
\end{eqnarray*}\]</span> as claimed.</p></li>
<li><p>Suppose <span class="math inline">\(z = \lamex{x}{e}\)</span>. Let <span class="math inline">\(y = \choice(\new(x,e,\sigma))\)</span>; note that by definition, if <span class="math inline">\(t \in \freeLambdaVars(e) \setminus \{x\}\)</span> then <span class="math inline">\(y \notin \freeLambdaVars(\sigma(t))\)</span>. Using the induction hypothesis, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \freeLambdaVars(\sigma[z]) \\
 &amp; = &amp; \freeLambdaVars(\sigma[\lamex{x}{e}]) \\
 &amp; = &amp; \freeLambdaVars(\lamex{y}{\sigma_{y/x}[e]}) \\
 &amp; = &amp; \freeLambdaVars(\sigma_{y/x}[e]) \setminus \{y\} \\
 &amp; = &amp; \left[ \bigcup_{t \in \freeLambdaVars(e)} \freeLambdaVars(\sigma_{y/x}(t)) \right] \setminus \{y\} \\
 &amp; = &amp; \left[ \freeLambdaVars(\sigma_{y/x}(x)) \cup \bigcup_{t \in \freeLambdaVars(e) \setminus \{x\}} \freeLambdaVars(\sigma_{y/x}(t)) \right] \setminus \{y\} \\
 &amp; = &amp; \left[ \freeLambdaVars(y) \cup \bigcup_{t \in \freeLambdaVars(e) \setminus \{x\}} \freeLambdaVars(\sigma(t)) \right] \setminus \{y\} \\
 &amp; = &amp; \left[ \bigcup_{t \in \freeLambdaVars(e) \setminus \{x\}} \freeLambdaVars(\sigma(t)) \right] \setminus \{y\} \\
 &amp; = &amp; \bigcup_{t \in \freeLambdaVars(\lamex{x}{e})} \freeLambdaVars(\sigma(t)) \\
 &amp; = &amp; \bigcup_{t \in \freeLambdaVars(z)} \freeLambdaVars(\sigma(t))
\end{eqnarray*}\]</span> as claimed.</p></li>
<li><p>Suppose <span class="math inline">\(z = \letin{x}{e_1}{e_2}\)</span>. Let <span class="math inline">\(y = \choice(\new(x,e_2,\sigma))\)</span>; note that by definition, if <span class="math inline">\(t \in \freeLambdaVars(e_2) \setminus \{x\}\)</span> then <span class="math inline">\(y \notin \freeLambdaVars(\sigma(t))\)</span>. Using the induction hypothesis, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \freeLambdaVars(\sigma[z]) \\
 &amp; = &amp; \freeLambdaVars(\sigma[\letin{x}{e_1}{e_2}]) \\
 &amp; = &amp; \freeLambdaVars(\letin{y}{\sigma[e_1]}{\sigma_{y/x}[e_2]}) \\
 &amp; = &amp; \freeLambdaVars(\sigma[e_1]) \cup (\freeLambdaVars(\sigma_{y/x}[e_2]) \setminus \{y\}) \\
 &amp; = &amp; \left[ \bigcup_{t \in \freeLambdaVars(e_1)} \freeLambdaVars(\sigma(t)) \right] \cup \left[ \left( \bigcup_{t \in \freeLambdaVars(e_2)} \freeLambdaVars(\sigma_{y/x}(t)) \right) \setminus \{y\} \right] \\
 &amp; = &amp; \left[ \bigcup_{t \in \freeLambdaVars(e_1)} \freeLambdaVars(\sigma(t)) \right] \cup \left[ \left( \freeLambdaVars(\sigma_{y/x}(x)) \cup \bigcup_{t \in \freeLambdaVars(e_2) \setminus \{x\}} \freeLambdaVars(\sigma_{y/x}(t)) \right) \setminus \{y\} \right] \\
 &amp; = &amp; \left[ \bigcup_{t \in \freeLambdaVars(e_1)} \freeLambdaVars(\sigma(t)) \right] \cup \left[ \left( \freeLambdaVars(y) \cup \bigcup_{t \in \freeLambdaVars(e_2) \setminus \{x\}} \freeLambdaVars(\sigma(t)) \right) \setminus \{y\} \right] \\
 &amp; = &amp; \left[ \bigcup_{t \in \freeLambdaVars(e_1)} \freeLambdaVars(\sigma(t)) \right] \cup \left[ \bigcup_{t \in \freeLambdaVars(e_2) \setminus \{x\}} \freeLambdaVars(\sigma(t)) \right] \\
 &amp; = &amp; \bigcup_{t \in \freeLambdaVars(e_1) \cup (\freeLambdaVars(e_2) \setminus \{x\})} \freeLambdaVars(\sigma(t)) \\
 &amp; = &amp; \bigcup_{t \in \freeLambdaVars(\letin{x}{e_1}{e_2})} \freeLambdaVars(\sigma(t)) \\
 &amp; = &amp; \bigcup_{t \in \freeLambdaVars(z)} \freeLambdaVars(\sigma(t))
\end{eqnarray*}\]</span> as claimed.</p></li>
<li>Suppose <span class="math inline">\(z = \apply{e_1}{e_2}\)</span>. Then we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \freeLambdaVars(\sigma[z]) \\
 &amp; = &amp; \freeLambdaVars(\sigma[\apply{e_1}{e_2}]) \\
 &amp; = &amp; \freeLambdaVars(\apply{\sigma[e_1]}{\sigma[e_2]}) \\
 &amp; = &amp; \freeLambdaVars(\sigma[e_1]) \cup \freeLambdaVars(\sigma[e_2]) \\
 &amp; = &amp; \bigcup_{t \in \freeLambdaVars(e_1)} \freeLambdaVars(\sigma(t)) \cup \bigcup_{t \in \freeLambdaVars(e_2)} \freeLambdaVars(\sigma(t)) \\
 &amp; = &amp; \bigcup_{t \in \freeLambdaVars(e_1) \cup \freeLambdaVars(e_2)} \freeLambdaVars(\sigma(t)) \\
 &amp; = &amp; \bigcup_{t \in \freeLambdaVars(\apply{e_1}{e_2})} \freeLambdaVars(\sigma(t)) \\
 &amp; = &amp; \bigcup_{t \in \freeLambdaVars(z)} \freeLambdaVars(\sigma(t))
\end{eqnarray*}\]</span> as claimed.</li>
</ol>
</div>
</div>
<p>We can also express this theorem as a property test.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1">prop_free_vars_in_applied_lambda_sub</a>
<a class="sourceLine" id="cb12-2" title="2"><span class="ot">  ::</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">LambdaTerm</span> a <span class="ot">-&gt;</span> <span class="dt">M.Map</span> <span class="dt">LambdaVariable</span> (<span class="dt">LambdaTerm</span> a) <span class="ot">-&gt;</span> <span class="dt">Property</span></a>
<a class="sourceLine" id="cb12-3" title="3">prop_free_vars_in_applied_lambda_sub z sigma <span class="ot">=</span></a>
<a class="sourceLine" id="cb12-4" title="4">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb12-5" title="5"><span class="ot">    freeVarsInImage ::</span> <span class="dt">LambdaVariable</span> <span class="ot">-&gt;</span> <span class="dt">S.Set</span> <span class="dt">LambdaVariable</span></a>
<a class="sourceLine" id="cb12-6" title="6">    freeVarsInImage t <span class="ot">=</span> <span class="kw">case</span> M.lookup t sigma <span class="kw">of</span></a>
<a class="sourceLine" id="cb12-7" title="7">      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> S.singleton t</a>
<a class="sourceLine" id="cb12-8" title="8">      <span class="dt">Just</span> e  <span class="ot">-&gt;</span> freeLambdaVariablesInLambdaTerm e</a>
<a class="sourceLine" id="cb12-9" title="9"></a>
<a class="sourceLine" id="cb12-10" title="10">  <span class="kw">in</span> (<span class="op">===</span>)</a>
<a class="sourceLine" id="cb12-11" title="11">    (freeLambdaVariablesInLambdaTerm (applySubToLambdaTerm sigma z))</a>
<a class="sourceLine" id="cb12-12" title="12">    (S.unions <span class="op">$</span> S.map freeVarsInImage <span class="op">$</span> freeLambdaVariablesInLambdaTerm z)</a></code></pre></div>
<p>Next, we can characterize the free variables in a pointwise update.</p>
<div class="theorem">
<p><a name='crossref-2'></a> Let <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> be variables, <span class="math inline">\(z\)</span> a <span class="math inline">\(\lambda\)</span>-term, and <span class="math inline">\(\sigma\)</span> a substitution. Then we have <span class="math display">\[\freeLambdaVars(\sigma_{y/x}[z]) = \left[ \bigcup_{t \in \freeLambdaVars(z) \setminus \{x\}} \freeLambdaVars(\sigma(t)) \right] \cup \left\{\begin{array}{ll} \{y\} &amp; \mathrm{if}\ x \in \freeLambdaVars(z) \\ \varnothing &amp; \mathrm{otherwise}. \end{array}\right.\]</span> In particular, for <span class="math inline">\(\sigma = \mathsf{id}\)</span>, we have <span class="math display">\[\freeLambdaVars(\mathsf{id}_{y/x}[z]) = (\freeLambdaVars(z) \setminus \{x\}) \cup \left\{\begin{array}{ll} \{y\} &amp; \mathrm{if}\ x \in \freeLambdaVars(z) \\ \varnothing &amp; \mathrm{otherwise}. \end{array}\right.\]</span></p>
<div class="proof">
<p>Using the previous characterization of the <a href="LambdaTerm.html#crossref-1">free variables in an applied substitution</a>, we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \freeLambdaVars(\sigma_{y/x}[z]) \\
 &amp; = &amp; \bigcup_{t \in \freeLambdaVars(z)} \freeLambdaVars(\sigma_{y/z}(t)) \\
 &amp; = &amp; \left[ \bigcup_{t \in \freeLambdaVars(z) \setminus \{x\}} \freeLambdaVars(\sigma_{y/x}(t)) \right] \cup \left\{\begin{array}{ll} \freeLambdaVars(\sigma_{y/x}(x)) &amp; \mathrm{if}\ x \in \freeLambdaVars(z) \\ \varnothing &amp; \mathrm{otherwise} \end{array}\right. \\
 &amp; = &amp; \left[ \bigcup_{t \in \freeLambdaVars(z) \setminus \{x\}} \freeLambdaVars(\sigma(t)) \right] \cup \left\{\begin{array}{ll} \freeLambdaVars(y) &amp; \mathrm{if}\ x \in \freeLambdaVars(z) \\ \varnothing &amp; \mathrm{otherwise} \end{array}\right. \\
 &amp; = &amp; \left[ \bigcup_{t \in \freeLambdaVars(z) \setminus \{x\}} \freeLambdaVars(\sigma(t)) \right] \cup \left\{\begin{array}{ll} \{y\} &amp; \mathrm{if}\ x \in \freeLambdaVars(z) \\ \varnothing &amp; \mathrm{otherwise} \end{array}\right.
\end{eqnarray*}\]</span> as claimed.</p>
</div>
</div>
<p>As a property test:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1">prop_free_vars_in_applied_pointwise_update_sub</a>
<a class="sourceLine" id="cb13-2" title="2"><span class="ot">  ::</span> <span class="kw">forall</span> a</a>
<a class="sourceLine" id="cb13-3" title="3">   <span class="op">.</span> (<span class="dt">LambdaAnnotation</span> a)</a>
<a class="sourceLine" id="cb13-4" title="4">  <span class="ot">=&gt;</span> <span class="dt">LambdaVariable</span> <span class="ot">-&gt;</span> <span class="dt">LambdaVariable</span></a>
<a class="sourceLine" id="cb13-5" title="5">  <span class="ot">-&gt;</span> <span class="dt">LambdaTerm</span> a <span class="ot">-&gt;</span> <span class="dt">M.Map</span> <span class="dt">LambdaVariable</span> (<span class="dt">LambdaTerm</span> a) <span class="ot">-&gt;</span> <span class="dt">Property</span></a>
<a class="sourceLine" id="cb13-6" title="6">prop_free_vars_in_applied_pointwise_update_sub y x z sigma <span class="ot">=</span></a>
<a class="sourceLine" id="cb13-7" title="7">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb13-8" title="8"><span class="ot">    freeVarsInImage ::</span> <span class="dt">LambdaVariable</span> <span class="ot">-&gt;</span> <span class="dt">S.Set</span> <span class="dt">LambdaVariable</span></a>
<a class="sourceLine" id="cb13-9" title="9">    freeVarsInImage t <span class="ot">=</span> <span class="kw">case</span> M.lookup t sigma <span class="kw">of</span></a>
<a class="sourceLine" id="cb13-10" title="10">      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> S.singleton t</a>
<a class="sourceLine" id="cb13-11" title="11">      <span class="dt">Just</span> e  <span class="ot">-&gt;</span> freeLambdaVariablesInLambdaTerm e</a>
<a class="sourceLine" id="cb13-12" title="12"></a>
<a class="sourceLine" id="cb13-13" title="13">    freeVarsInImages <span class="ot">=</span> S.unions <span class="op">$</span> S.map freeVarsInImage <span class="op">$</span></a>
<a class="sourceLine" id="cb13-14" title="14">      S.delete x <span class="op">$</span> freeLambdaVariablesInLambdaTerm z</a>
<a class="sourceLine" id="cb13-15" title="15"></a>
<a class="sourceLine" id="cb13-16" title="16">    freeVarsInUpdate <span class="ot">=</span> freeLambdaVariablesInLambdaTerm <span class="op">$</span></a>
<a class="sourceLine" id="cb13-17" title="17">      applySubToLambdaTerm (variableUpdateSub y x sigma) z</a>
<a class="sourceLine" id="cb13-18" title="18"></a>
<a class="sourceLine" id="cb13-19" title="19">  <span class="kw">in</span> <span class="kw">if</span> S.member x (freeLambdaVariablesInLambdaTerm z)</a>
<a class="sourceLine" id="cb13-20" title="20">    <span class="kw">then</span> (<span class="op">===</span>)</a>
<a class="sourceLine" id="cb13-21" title="21">      (freeVarsInUpdate)</a>
<a class="sourceLine" id="cb13-22" title="22">      (S.union freeVarsInImages (S.singleton y))</a>
<a class="sourceLine" id="cb13-23" title="23">    <span class="kw">else</span> (<span class="op">===</span>)</a>
<a class="sourceLine" id="cb13-24" title="24">      (freeVarsInUpdate)</a>
<a class="sourceLine" id="cb13-25" title="25">      (freeVarsInImages)</a></code></pre></div>
<p>We also have a sort of composition on substitutions, although it's not the usual function composition.</p>
<div class="definition">
<p>Given substitutions <span class="math inline">\(\sigma_1\)</span> and <span class="math inline">\(\sigma_2\)</span>, we define their <em>composite</em> <span class="math inline">\(\sigma_2 \sigma_1\)</span> by <span class="math display">\[(\sigma_2 \sigma_1)(x) = \sigma_2[\sigma_1(x)].\]</span></p>
</div>
<p>Translating composition to Haskell is a little trickier because we're representing substitutions as finite maps; just note that if <span class="math inline">\(\sigma_2 \sigma_1\)</span> moves a variable, then it must have been in the support of either <span class="math inline">\(\sigma_1\)</span> or <span class="math inline">\(\sigma_2\)</span>.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1">composeLambdaSubs</a>
<a class="sourceLine" id="cb14-2" title="2"><span class="ot">  ::</span> <span class="dt">M.Map</span> <span class="dt">LambdaVariable</span> (<span class="dt">LambdaTerm</span> a)</a>
<a class="sourceLine" id="cb14-3" title="3">  <span class="ot">-&gt;</span> <span class="dt">M.Map</span> <span class="dt">LambdaVariable</span> (<span class="dt">LambdaTerm</span> a)</a>
<a class="sourceLine" id="cb14-4" title="4">  <span class="ot">-&gt;</span> <span class="dt">M.Map</span> <span class="dt">LambdaVariable</span> (<span class="dt">LambdaTerm</span> a)</a>
<a class="sourceLine" id="cb14-5" title="5">composeLambdaSubs sigma2 sigma1 <span class="ot">=</span></a>
<a class="sourceLine" id="cb14-6" title="6">  <span class="fu">foldr</span> f M.empty (S.union (M.keysSet sigma1) (M.keysSet sigma2))</a>
<a class="sourceLine" id="cb14-7" title="7">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-8" title="8">    f x sigma <span class="ot">=</span> <span class="kw">case</span> M.lookup x sigma1 <span class="kw">of</span></a>
<a class="sourceLine" id="cb14-9" title="9">      <span class="dt">Just</span> e  <span class="ot">-&gt;</span> M.insert x (applySubToLambdaTerm sigma2 e) sigma</a>
<a class="sourceLine" id="cb14-10" title="10">      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">case</span> M.lookup x sigma2 <span class="kw">of</span></a>
<a class="sourceLine" id="cb14-11" title="11">        <span class="dt">Just</span> e  <span class="ot">-&gt;</span> M.insert x e sigma</a>
<a class="sourceLine" id="cb14-12" title="12">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> sigma</a></code></pre></div>
<p>At this point there are several properties about free variables and substitution we'd like to prove, however we're not quite ready yet. We need a looser notion of equality for <span class="math inline">\(\lambda\)</span>-terms that captures the intuition that "renaming the bound variables" doesn't fundamentally change the <em>meaning</em> of a term. This is what we'll discuss next.</p>
</section>
<section class="level2">
<h2>Alpha Equivalence</h2>
<p>We define an equivalence relation on <span class="math inline">\(\LambdaTerms\)</span> as follows.</p>
<div class="definition">
<p>(<span class="math inline">\(\alpha\)</span>-equivalence.) We denote by <span class="math inline">\(\AlphaEq\)</span> the smallest equivalence relation on <span class="math inline">\(\LambdaTerms\)</span> which satisfies the following.</p>
<ol>
<li><span class="math inline">\(\lamex{x}{e} \AlphaEq \lamex{y}{f}\)</span> if either
<ol>
<li><span class="math inline">\(x = y\)</span> and <span class="math inline">\(e \AlphaEq f\)</span></li>
<li><span class="math inline">\(y \notin \freeLambdaVars(e)\)</span> and <span class="math inline">\(\mathsf{id}_{y/x}[e] \AlphaEq f\)</span>.</li>
</ol></li>
<li><span class="math inline">\(\letin{x}{e_1}{e_2} \AlphaEq \letin{y}{f_1}{f_2}\)</span> if <span class="math inline">\(e_1 \AlphaEq f_1\)</span> and either
<ol>
<li><span class="math inline">\(x = y\)</span> and <span class="math inline">\(e_2 \AlphaEq f_2\)</span></li>
<li><span class="math inline">\(y \notin \freeLambdaVars(e_2)\)</span> and <span class="math inline">\(\mathsf{id}_{y/x}[e_2] \AlphaEq f_2\)</span>.</li>
</ol></li>
<li><span class="math inline">\(\apply{e_1}{e_2} \AlphaEq \apply{f_1}{f_2}\)</span> if <span class="math inline">\(e_1 \AlphaEq f_1\)</span> and <span class="math inline">\(e_2 \AlphaEq f_2\)</span>.</li>
</ol>
<p>The hypothesis of (1) will play a role in several results later, so we abbreviate it <span class="math inline">\(\mathcal{A}(e,x,f,y)\)</span>. Similarly, the hypothesis of (2) is abbreviated <span class="math inline">\(\mathcal{B}(e_1,e_2,x,f_1,f_2,y)\)</span>.</p>
</div>
<p>Again, at first this might seem like an odd way to define an equivalence relation, but we can take the intersection over all equivalences which satisfy the properties (and there's at least one, since the universal relation does). We can go a bit further; the union of the universal relations on terms of each "form" satisfies the conditions, so for example we can say that if <span class="math inline">\(z\)</span> is a lambda abstraction and <span class="math inline">\(z \AlphaEq w\)</span>, then <span class="math inline">\(w\)</span> is also a lambda abstraction. This definition does not, however, immediately yield a recursive function to actually decide whether or not two terms are <span class="math inline">\(\alpha\)</span>-equivalent.</p>
<p>We can extend <span class="math inline">\(\alpha\)</span>-equivalence to substitutions. Given substitutions <span class="math inline">\(\sigma_1\)</span> and <span class="math inline">\(\sigma_2\)</span> and a set <span class="math inline">\(A\)</span> of variables, we say that <span class="math inline">\(\sigma_1 \AlphaEq^A \sigma_2\)</span> if <span class="math inline">\(\sigma_1(a) \AlphaEq \sigma_2(a)\)</span> for all <span class="math inline">\(a \in A\)</span>, and we say <span class="math inline">\(\sigma_1 \AlphaEq \sigma_2\)</span> if <span class="math inline">\(\sigma_1 \AlphaEq^{\LambdaIdents} \sigma_2\)</span>.</p>
<div class="lemma">
<p><a name='crossref-3'></a> We have the following.</p>
<ol>
<li><p>If <span class="math inline">\(y \notin \freeLambdaVars(e)\)</span>, then <span class="math inline">\(\lamex{x}{e} \AlphaEq \lamex{y}{\mathsf{id}_{y/x}[e]}\)</span>.</p></li>
<li><p>If <span class="math inline">\(y \notin \freeLambdaVars(e_2)\)</span>, then <span class="math inline">\(\letin{x}{e_1}{e_2} \AlphaEq \letin{y}{e_1}{\mathsf{id}_{y/x}[e_2]}\)</span>.</p></li>
</ol>
<div class="proof">
<p>To see (1), note that <span class="math inline">\(\mathsf{id}_{y/x}[e] \AlphaEq \mathsf{id}_{y/x}[e]\)</span> since <span class="math inline">\(\AlphaEq\)</span> is reflexive; then the conclusion follows from the defining property of <span class="math inline">\(\AlphaEq\)</span> for lambda expressions.</p>
<p>To see (2), note that <span class="math inline">\(e_1 \AlphaEq e_1\)</span> and <span class="math inline">\(\mathsf{id}_{y/x}[e_2] \AlphaEq \mathsf{id}_{y/x}[e_2]\)</span> by reflexivity; the conclusion follows from the defining property of <span class="math inline">\(\AlphaEq\)</span> for let expressions.</p>
</div>
</div>
<p>We haven't seen the Haskell implementation of <span class="math inline">\(\alpha\)</span>-equivalence yet, but we can still hit this theorem with a property test.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1">prop_lambda_expr_alpha_eq_lemma</a>
<a class="sourceLine" id="cb15-2" title="2"><span class="ot">  ::</span> <span class="kw">forall</span> a<span class="op">.</span> (<span class="dt">LambdaAnnotation</span> a, <span class="dt">Show</span> a)</a>
<a class="sourceLine" id="cb15-3" title="3">  <span class="ot">=&gt;</span> <span class="dt">LambdaVariable</span> <span class="ot">-&gt;</span> <span class="dt">LambdaVariable</span> <span class="ot">-&gt;</span> <span class="dt">LambdaTerm</span> a <span class="ot">-&gt;</span> <span class="dt">Property</span></a>
<a class="sourceLine" id="cb15-4" title="4">prop_lambda_expr_alpha_eq_lemma x y e <span class="ot">=</span></a>
<a class="sourceLine" id="cb15-5" title="5">  (S.notMember y (freeLambdaVariablesInLambdaTerm e))</a>
<a class="sourceLine" id="cb15-6" title="6">    <span class="op">==&gt;</span></a>
<a class="sourceLine" id="cb15-7" title="7">  (alphaEqTerm</a>
<a class="sourceLine" id="cb15-8" title="8">    (lambda x e)</a>
<a class="sourceLine" id="cb15-9" title="9">    (lambda y (applySubToLambdaTerm (variableUpdateSub y x identitySub) e)))</a>
<a class="sourceLine" id="cb15-10" title="10"></a>
<a class="sourceLine" id="cb15-11" title="11">prop_let_expr_alpha_eq_lemma</a>
<a class="sourceLine" id="cb15-12" title="12"><span class="ot">  ::</span> <span class="kw">forall</span> a<span class="op">.</span> (<span class="dt">LambdaAnnotation</span> a, <span class="dt">Show</span> a)</a>
<a class="sourceLine" id="cb15-13" title="13">  <span class="ot">=&gt;</span> <span class="dt">LambdaVariable</span> <span class="ot">-&gt;</span> <span class="dt">LambdaVariable</span> <span class="ot">-&gt;</span> <span class="dt">LambdaTerm</span> a <span class="ot">-&gt;</span> <span class="dt">LambdaTerm</span> a <span class="ot">-&gt;</span> <span class="dt">Property</span></a>
<a class="sourceLine" id="cb15-14" title="14">prop_let_expr_alpha_eq_lemma x y e1 e2 <span class="ot">=</span></a>
<a class="sourceLine" id="cb15-15" title="15">  (S.notMember y (freeLambdaVariablesInLambdaTerm e2))</a>
<a class="sourceLine" id="cb15-16" title="16">    <span class="op">==&gt;</span></a>
<a class="sourceLine" id="cb15-17" title="17">  (alphaEqTerm</a>
<a class="sourceLine" id="cb15-18" title="18">    (letin x e1 e2)</a>
<a class="sourceLine" id="cb15-19" title="19">    (letin y e1 (applySubToLambdaTerm (variableUpdateSub y x identitySub) e2)))</a></code></pre></div>
<p>Free variables are invariant under <span class="math inline">\(\alpha\)</span>-equivalence.</p>
<div class="theorem">
<p><a name='crossref-4'></a> If <span class="math inline">\(z \AlphaEq w\)</span> then <span class="math inline">\(\freeLambdaVars(z) = \freeLambdaVars(w)\)</span>.</p>
<div class="proof">
<p>Define a relation <span class="math inline">\(\sim\)</span> on <span class="math inline">\(\LambdaTerms\)</span> by <span class="math inline">\(z \sim w\)</span> if and only if <span class="math inline">\(z \AlphaEq w\)</span> and <span class="math inline">\(\freeLambdaVars(z) = \freeLambdaVars(w)\)</span>; we show that <span class="math inline">\(\sim\)</span> satisfies the conditions on <span class="math inline">\(\AlphaEq\)</span>, so that <span class="math inline">\(\sim\)</span> equals <span class="math inline">\(\AlphaEq\)</span>. This requires examining five possibilities.</p>
<p>Suppose <span class="math inline">\(z = \lamex{x}{e}\)</span> and <span class="math inline">\(w = \lamex{y}{f}\)</span>. We consider two cases.</p>
<ol>
<li><p>Suppose <span class="math inline">\(x = y\)</span> and <span class="math inline">\(e \sim f\)</span>; that is, <span class="math inline">\(e \AlphaEq f\)</span> and <span class="math inline">\(\freeLambdaVars(e) = \freeLambdaVars(f)\)</span>. By the definition of <span class="math inline">\(\AlphaEq\)</span> we have <span class="math inline">\(z \AlphaEq w\)</span>, and moreover <span class="math display">\[\begin{eqnarray*}
  &amp;   &amp; \freeLambdaVars(z) \\
  &amp; = &amp; \freeLambdaVars(\lamex{x}{e}) \\
  &amp; = &amp; \freeLambdaVars(e) \setminus \{x\} \\
  &amp; = &amp; \freeLambdaVars(f) \setminus \{y\} \\
  &amp; = &amp; \freeLambdaVars(\lamex{y}{f}) \\
  &amp; = &amp; \freeLambdaVars(w),
 \end{eqnarray*}\]</span> so that <span class="math inline">\(z \sim w\)</span> as needed.</p></li>
<li><p>Suppose <span class="math inline">\(y \notin \freeLambdaVars(e)\)</span> and <span class="math inline">\(\mathsf{id}_{y/x}[e] \sim f\)</span>; that is, <span class="math inline">\(\mathsf{id}_{y/x}[e] \AlphaEq f\)</span> and <span class="math inline">\(\freeLambdaVars(\mathsf{id}_{y/x}[e]) = \freeLambdaVars(f)\)</span>. By the definition of <span class="math inline">\(\AlphaEq\)</span> we have <span class="math inline">\(z \AlphaEq w\)</span>, and moreover <span class="math display">\[\begin{eqnarray*}
  &amp;   &amp; \freeLambdaVars(z) \\
  &amp; = &amp; \freeLambdaVars(\lamex{x}{e}) \\
  &amp; = &amp; \freeLambdaVars(e) \setminus \{x\} \\
  &amp; = &amp; (\freeLambdaVars(e) \setminus \{x\}) \setminus\{y\} \\
  &amp; = &amp; \left((\freeLambdaVars(e) \setminus \{x\}) \cup \left\{\begin{array}{ll} \{y\} &amp; \mathrm{if}\ x \in \freeLambdaVars(e) \\ \varnothing &amp; \mathrm{otherwise} \end{array}\right\}\right) \setminus \{y\} \\
  &amp; = &amp; \freeLambdaVars(\mathsf{id}_{y/x}[e]) \setminus \{y\} \\
  &amp; = &amp; \freeLambdaVars(f) \setminus \{y\} \\
  &amp; = &amp; \freeLambdaVars(\lamex{y}{f}) \\
  &amp; = &amp; \freeLambdaVars(w)
 \end{eqnarray*}\]</span> so that <span class="math inline">\(z \sim w\)</span> as needed.</p></li>
</ol>
<p>Suppose <span class="math inline">\(z = \letin{x}{e_1}{e_2}\)</span> and <span class="math inline">\(w = \letin{y}{f_1}{f_2}\)</span>. We consider two cases.</p>
<ol>
<li><p>Suppose <span class="math inline">\(x = y\)</span>, <span class="math inline">\(e_2 \sim f_2\)</span>, and <span class="math inline">\(e_1 \sim f_1\)</span>. Now <span class="math inline">\(e_1 \AlphaEq f_1\)</span> and <span class="math inline">\(e_2 \AlphaEq f_2\)</span>, so that <span class="math inline">\(z \AlphaEq w\)</span>. Moreover, we have <span class="math display">\[\begin{eqnarray*}
  &amp;   &amp; \freeLambdaVars(z) \\
  &amp; = &amp; \freeLambdaVars(\letin{x}{e_1}{e_2}) \\
  &amp; = &amp; \freeLambdaVars(e_1) \cup (\freeLambdaVars(e_2) \setminus \{x\}) \\
  &amp; = &amp; \freeLambdaVars(f_1) \cup (\freeLambdaVars(f_2) \setminus \{y\}) \\
  &amp; = &amp; \freeLambdaVars(\letin{y}{f_1}{f_2}) \\
  &amp; = &amp; \freeLambdaVars(w)
 \end{eqnarray*}\]</span> so that <span class="math inline">\(z \sim w\)</span> as needed.</p></li>
<li><p>Suppose <span class="math inline">\(y \notin \freeLambdaVars(e_2)\)</span>, <span class="math inline">\(\mathsf{id}_{y/x}[e_2] \sim f_2\)</span>, and <span class="math inline">\(e_1 \sim f_1\)</span>. Now <span class="math inline">\(\mathsf{id}_{y/x}[e_2] \AlphaEq f_2\)</span> and <span class="math inline">\(e_1 \AlphaEq f_1\)</span> and <span class="math inline">\(\freeLambdaVars(\mathsf{id}_{y/x}[e_2]) = \freeLambdaVars(f_2)\)</span> and <span class="math inline">\(\freeLambdaVars(e_1) = \freeLambdaVars(f_1)\)</span>, so that <span class="math inline">\(z \AlphaEq w\)</span>. Moreover we have <span class="math display">\[\begin{eqnarray*}
  &amp;   &amp; \freeLambdaVars(z) \\
  &amp; = &amp; \freeLambdaVars(\letin{x}{e_1}{e_2}) \\
  &amp; = &amp; \freeLambdaVars(e_1) \cup (\freeLambdaVars(e_2) \setminus \{x\}) \\
  &amp; = &amp; \freeLambdaVars(e_1) \cup \left( (\freeLambdaVars(e_2) \setminus \{x\}) \setminus\{y\} \right) \\
  &amp; = &amp; \freeLambdaVars(e_1) \cup \left( \left((\freeLambdaVars(e_2) \setminus \{x\}) \cup \left\{\begin{array}{ll} \{y\} &amp; \mathrm{if}\ x \in \freeLambdaVars(e_2) \\ \varnothing &amp; \mathrm{otherwise} \end{array}\right\}\right) \setminus \{y\} \right) \\
  &amp; = &amp; \freeLambdaVars(e_1) \cup \left( \freeLambdaVars(\mathsf{id}_{y/x}[e_2]) \setminus \{y\} \right) \\
  &amp; = &amp; \freeLambdaVars(f_1) \cup (\freeLambdaVars(f_2) \setminus \{y\}) \\
  &amp; = &amp; \freeLambdaVars(\letin{y}{f_1}{f_2}) \\
  &amp; = &amp; \freeLambdaVars(w)
 \end{eqnarray*}\]</span> so that <span class="math inline">\(z \sim w\)</span> as needed.</p></li>
</ol>
<p>Suppose <span class="math inline">\(z = \apply{e_1}{e_2}\)</span> and <span class="math inline">\(w = \apply{f_1}{f_2}\)</span>, and suppose further that <span class="math inline">\(e_1 \sim f_1\)</span> and <span class="math inline">\(e_2 \sim f_2\)</span>; that is, <span class="math inline">\(e_1 \AlphaEq f_1\)</span> and <span class="math inline">\(e_2 \AlphaEq f_2\)</span> and <span class="math inline">\(\freeLambdaVars(e_1) = \freeLambdaVars(f_1)\)</span> and <span class="math inline">\(\freeLambdaVars(e_2) = \freeLambdaVars(f_2)\)</span>. By the definition of <span class="math inline">\(\AlphaEq\)</span> we have <span class="math inline">\(z \AlphaEq w\)</span>, and moreover <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \freeLambdaVars(z) \\
 &amp; = &amp; \freeLambdaVars(\apply{e_1}{e_2}) \\
 &amp; = &amp; \freeLambdaVars(e_1) \cup \freeLambdaVars(e_2) \\
 &amp; = &amp; \freeLambdaVars(f_1) \cup \freeLambdaVars(f_2) \\
 &amp; = &amp; \freeLambdaVars(\apply{f_1}{f_2}) \\
 &amp; = &amp; \freeLambdaVars(w)
\end{eqnarray*}\]</span> so that <span class="math inline">\(z \sim w\)</span> as needed.</p>
<p>That is, <span class="math inline">\(\sim\)</span> satisfies the condition from the definition of <span class="math inline">\(\AlphaEq\)</span>, and thus <span class="math inline">\(\AlphaEq\)</span> is contained in <span class="math inline">\(\sim\)</span> as a set by minimalness. On the other hand, <span class="math inline">\(\sim\)</span> is contained in <span class="math inline">\(\AlphaEq\)</span> by definition. So in fact <span class="math inline">\(\sim\)</span> is equal to <span class="math inline">\(\AlphaEq\)</span>. More explicitly, if <span class="math inline">\(z \AlphaEq w\)</span>, then <em>both</em> <span class="math inline">\(z \AlphaEq w\)</span> and <span class="math inline">\(\freeLambdaVars(z) = \freeLambdaVars(w)\)</span>, as claimed.</p>
</div>
</div>
<p>This claim is also amenable to property testing, although it is difficult to construct random <span class="math inline">\(\alpha\)</span>-equivalent pairs to test. This makes the test of lower quality than unqualified property tests, although it's not without value.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1">prop_alpha_eq_implies_same_free_vars</a>
<a class="sourceLine" id="cb16-2" title="2"><span class="ot">  ::</span> <span class="kw">forall</span> a<span class="op">.</span> (<span class="dt">Show</span> a)</a>
<a class="sourceLine" id="cb16-3" title="3">  <span class="ot">=&gt;</span> <span class="dt">LambdaTerm</span> a <span class="ot">-&gt;</span> <span class="dt">LambdaTerm</span> a <span class="ot">-&gt;</span> <span class="dt">Property</span></a>
<a class="sourceLine" id="cb16-4" title="4">prop_alpha_eq_implies_same_free_vars z w <span class="ot">=</span></a>
<a class="sourceLine" id="cb16-5" title="5">  <span class="kw">if</span> alphaEqTerm z w</a>
<a class="sourceLine" id="cb16-6" title="6">    <span class="kw">then</span> (<span class="op">===</span>)</a>
<a class="sourceLine" id="cb16-7" title="7">      (freeLambdaVariablesInLambdaTerm z)</a>
<a class="sourceLine" id="cb16-8" title="8">      (freeLambdaVariablesInLambdaTerm w)</a>
<a class="sourceLine" id="cb16-9" title="9">    <span class="kw">else</span> property succeeded</a></code></pre></div>
<p>As a consequence of free variable preservation, we can boost <span class="math inline">\(\alpha\)</span>-equivalences to an equality of <span class="math inline">\(\new\)</span> sets.</p>
<div class="corollary">
<p><a name='crossref-5'></a> If <span class="math inline">\(z_1 \AlphaEq z_2\)</span> and <span class="math inline">\(\sigma_1 \AlphaEq^{\freeLambdaVars(z_1) \setminus \{x\}} \sigma_2\)</span>, then <span class="math inline">\(\new(x,z_1,\sigma_1) = \new(x,z_2,\sigma_2)\)</span>.</p>
<div class="proof">
<p>Because <span class="math inline">\(\alpha\)</span>-equivalence preserves free variables, we have <span class="math inline">\(\freeLambdaVars(z_1) = \freeLambdaVars(z_2)\)</span> and <span class="math inline">\(\freeLambdaVars(\sigma_1(u)) = \freeLambdaVars(\sigma_2(u))\)</span> for all <span class="math inline">\(u \in \freeLambdaVars(z_1) \setminus \{x\}\)</span>. Then <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \new(x,z_1,\sigma_1) \\
 &amp; = &amp; \{ y \in \LambdaIdents \mid \mathrm{if}\ u \in \freeLambdaVars(z_1) \setminus \{x\}\ \mathrm{then}\ y \notin \freeLambdaVars(\sigma_1(u)) \} \\
 &amp; = &amp; \{ y \in \LambdaIdents \mid \mathrm{if}\ u \in \freeLambdaVars(z_1) \setminus \{x\}\ \mathrm{then}\ y \notin \freeLambdaVars(\sigma_2(u)) \} \\
 &amp; = &amp; \{ y \in \LambdaIdents \mid \mathrm{if}\ u \in \freeLambdaVars(z_2) \setminus \{x\}\ \mathrm{then}\ y \notin \freeLambdaVars(\sigma_2(u)) \} \\
 &amp; = &amp; \new(x,z_2,\sigma_2)
\end{eqnarray*}\]</span> as claimed.</p>
</div>
</div>
<p>If substitutions are equal on the free variables of an expression, then their applications to the expression are also equal (not merely <span class="math inline">\(\alpha\)</span>-equivalent).</p>
<div class="theorem">
<p><a name='crossref-6'></a> Let <span class="math inline">\(z\)</span> be a <span class="math inline">\(\lambda\)</span>-term and <span class="math inline">\(\sigma_1, \sigma_2\)</span> substitutions. If <span class="math inline">\(\sigma_1 =^{\freeLambdaVars(z)} \sigma_2\)</span>, then <span class="math inline">\(\sigma_1[z] = \sigma_2[z]\)</span>.</p>
<div class="proof">
<p>Note that this statement involves <em>equality</em>, not <span class="math inline">\(\alpha\)</span>-equivalence. We proceed by structural induction on <span class="math inline">\(z\)</span>.</p>
<ol>
<li><p>Suppose <span class="math inline">\(z \in \LambdaIdents\)</span>. Now <span class="math inline">\(\freeLambdaVars(z) = \{z\}\)</span>, and using the hypothesis we have <span class="math display">\[\sigma_1[z] = \sigma_1(z) = \sigma_2(z) = \sigma_2[z]\]</span> as claimed.</p></li>
<li><p>Suppose <span class="math inline">\(z \in \LambdaConsts\)</span>; then <span class="math inline">\(\sigma_1[z] = z = \sigma_2[z]\)</span> as claimed.</p></li>
<li><p>Suppose <span class="math inline">\(z = \lamex{x}{e}\)</span>. Now <span class="math inline">\(\freeLambdaVars(z) = \freeLambdaVars(e) \setminus \{x\}\)</span> and (using the hypothesis) <span class="math inline">\(\sigma_{1, y/x}[e] =^{\freeLambdaVars(e) \setminus \{x\}} \sigma_{2, y/x}\)</span>. By reflexivity we have <span class="math inline">\(e \AlphaEq e\)</span>. Now using the <a href="LambdaTerm.html#crossref-5">previous result</a>, we have <span class="math inline">\(\new(x,e,\sigma_1) = \new(x,e,\sigma_2)\)</span>. Using the inductive hypothesis we then have <span class="math display">\[\begin{eqnarray*}
  &amp;   &amp; \sigma_1[z] \\
  &amp; = &amp; \sigma_1[\lamex{x}{e}] \\
  &amp; = &amp; \lamex{y}{\sigma_{1, y/x}[e]}\ \mathrm{where}\ y = \choice(\new(x,z,\sigma_1)) \\
  &amp; = &amp; \lamex{y}{\sigma_{2, y/x}[e]}\ \mathrm{where}\ y = \choice(\new(x,z,\sigma_2)) \\
  &amp; = &amp; \sigma_2[\lamex{x}{e}] \\
  &amp; = &amp; \sigma_2[z]
 \end{eqnarray*}\]</span> as claimed.</p></li>
<li><p>Suppose <span class="math inline">\(z = \letin{x}{e_1}{e_2}\)</span>. Now <span class="math inline">\(\freeLambdaVars(z) = \freeLambdaVars(e_1) \cup (\freeLambdaVars(e_2) \setminus \{x\})\)</span>. Using the hypothesis, we have <span class="math inline">\(\sigma_1 =^{\freeLambdaVars(e_1)} \sigma_2\)</span> and <span class="math inline">\(\sigma_{1, y/x} =^{\freeLambdaVars(e_2) \setminus \{x\}} \sigma_{2, y/x}\)</span>. By reflexivity we have <span class="math inline">\(e_2 \AlphaEq e_2\)</span>, and using the <a href="LambdaTerm.html#crossref-5">previous result</a>, we have <span class="math inline">\(\new(x,e_2,\sigma_1) = \new(x,e_2,\sigma_2)\)</span>. Using the inductive hypothesis, we then have <span class="math display">\[\begin{eqnarray*}
  &amp;   &amp; \sigma_1[z] \\
  &amp; = &amp; \sigma_1[\letin{x}{e_1}{e_2}] \\
  &amp; = &amp; \letin{y}{\sigma_1[e_1]}{\sigma_{1, y/x}[e_2]}\ \mathrm{where}\ y = \choice(\new(x,e_1,\sigma_1)) \\
  &amp; = &amp; \letin{y}{\sigma_2[e_1]}{\sigma_{2, y/x}[e_2]}\ \mathrm{where}\ y = \choice(\new(x,e_2,\sigma_2)) \\
  &amp; = &amp; \sigma_2[\letin{x}{e_1}{e_2}] \\
  &amp; = &amp; \sigma_2[z]
 \end{eqnarray*}\]</span> as claimed.</p></li>
<li>Suppose <span class="math inline">\(z = \apply{e_1}{e_2}\)</span>. Now <span class="math inline">\(\freeLambdaVars(z) = \freeLambdaVars(e_1) \cup \freeLambdaVars(e_2)\)</span>, so that <span class="math inline">\(\sigma_1 =^{\freeLambdaVars(e_1)} \sigma_2\)</span> and <span class="math inline">\(\sigma_1 =^{\freeLambdaVars(e_2)} \sigma_2\)</span>. Using the inductive hypothesis we have <span class="math display">\[\begin{eqnarray*}
  &amp;   &amp; \sigma_1[z] \\
  &amp; = &amp; \sigma_1[\apply{e_1}{e_2}] \\
  &amp; = &amp; \apply{\sigma_1[e_1]}{\sigma_1[e_2]} \\
  &amp; = &amp; \apply{\sigma_2[e_1]}{\sigma_2[e_2]} \\
  &amp; = &amp; \sigma_2[\apply{e_1}{e_2}] \\
  &amp; = &amp; \sigma_2[z]
 \end{eqnarray*}\]</span> as claimed.</li>
</ol>
</div>
</div>
<p>Another result that seems obvious, but has to be proved: applying the identity substitution yields an <span class="math inline">\(\alpha\)</span>-equivalent term.</p>
<div class="theorem">
<p><a name='crossref-7'></a> Given a <span class="math inline">\(\lambda\)</span>-term <span class="math inline">\(z\)</span>, we have <span class="math inline">\(\mathsf{id}[z] \AlphaEq z\)</span>.</p>
<div class="proof">
<p>We proceed by structural induction on <span class="math inline">\(z\)</span>.</p>
<ol>
<li><p>If <span class="math inline">\(z \in \LambdaIdents\)</span>, then we have <span class="math display">\[\mathsf{id}[z] = \mathsf{id}(z) = z \AlphaEq z\]</span> as claimed.</p></li>
<li><p>If <span class="math inline">\(z \in \LambdaConsts\)</span>, then we have <span class="math inline">\(\mathsf{id}[z] = z \AlphaEq z\)</span> as claimed.</p></li>
<li><p>Suppose <span class="math inline">\(z = \lamex{x}{e}\)</span> and let <span class="math inline">\(y = \choice(\new(x,e,\mathsf{id}))\)</span>. We claim that <span class="math inline">\(y\)</span> is not free in <span class="math inline">\(e\)</span>; to see why, note that if so then from the definition of <span class="math inline">\(\new\)</span> we have <span class="math inline">\(y \notin \freeLambdaVars(\mathsf{id}(y)) = \{y\}\)</span>. Then using a <a href="LambdaTerm.html#crossref-3">previous lemma</a> we have <span class="math inline">\(\lamex{x}{e} \AlphaEq \lamex{y}{\mathsf{id}_{y/x}[e]}\)</span>. Then <span class="math display">\[\begin{eqnarray*}
  &amp;          &amp; \mathsf{id}[z] \\
  &amp; =        &amp; \mathsf{id}[\lamex{x}{e}] \\
  &amp; =        &amp; \lamex{y}{\mathsf{id}_{y/x}[e]} \\
  &amp; \AlphaEq &amp; \lamex{x}{e} \\
  &amp; =        &amp; z
 \end{eqnarray*}\]</span> as claimed.</p></li>
<li><p>Suppose <span class="math inline">\(z = \letin{x}{e_1}{e_2}\)</span> and let <span class="math inline">\(y = \choice(\new(x,e,\mathsf{id}))\)</span>. As in the previous case, <span class="math inline">\(y\)</span> is not free in <span class="math inline">\(e_2\)</span>, so that by a <a href="LambdaTerm.html#crossref-3">previous lemma</a> we have <span class="math inline">\(\lamex{x}{e} \AlphaEq \lamex{y}{\mathsf{id}_{y/x}[e_2]}\)</span>. Using the inductive hypothesis we have <span class="math display">\[\begin{eqnarray*}
  &amp;          &amp; \mathsf{id}[z] \\
  &amp; =        &amp; \mathsf{id}[\letin{x}{e_1}{e_2}] \\
  &amp; =        &amp; \letin{y}{\mathsf{id}[e_1]}{\mathsf{id}_{y/x}[e_2]} \\
  &amp; \AlphaEq &amp; \letin{y}{e_1}{\mathsf{id}_{y/x}[e_2]} \\
  &amp; \AlphaEq &amp; \letin{x}{e_1}{e_2} \\
  &amp; =        &amp; z
 \end{eqnarray*}\]</span> so that <span class="math inline">\(\mathsf{id}[z] \AlphaEq z\)</span> by transitivity.</p></li>
<li>Suppose <span class="math inline">\(z = \apply{e_1}{e_2}\)</span>. Using the inductive hypothesis we have <span class="math display">\[\begin{eqnarray*}
  &amp;          &amp; \mathsf{id}[z] \\
  &amp; =        &amp; \mathsf{id}[\apply{e_1}{e_2}] \\
  &amp; =        &amp; \apply{\mathsf{id}[e_1]}{\mathsf{id}[e_2]} \\
  &amp; \AlphaEq &amp; \apply{e_1}{e_2} \\
  &amp; =        &amp; z
 \end{eqnarray*}\]</span> as claimed.</li>
</ol>
</div>
</div>
<p>This theorem is another good candidate for property testing.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1">prop_identity_subst_alpha_eq</a>
<a class="sourceLine" id="cb17-2" title="2"><span class="ot">  ::</span> <span class="kw">forall</span> a<span class="op">.</span> (<span class="dt">Show</span> a)</a>
<a class="sourceLine" id="cb17-3" title="3">  <span class="ot">=&gt;</span> <span class="dt">LambdaTerm</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb17-4" title="4">prop_identity_subst_alpha_eq z <span class="ot">=</span></a>
<a class="sourceLine" id="cb17-5" title="5">  alphaEqTerm z (applySubToLambdaTerm identitySub z)</a></code></pre></div>
<p>We can say something very strong about the sets of new variables for expressions which satisfy the hypotheses from the definition of <span class="math inline">\(\alpha\)</span>-equivalence.</p>
<div class="theorem">
<p><a name='crossref-8'></a> We have the following.</p>
<ol>
<li>If <span class="math inline">\(\mathcal{A}(e,x,f,y)\)</span>, then <span class="math inline">\(\new(x,e,\sigma) = \new(y,f,\sigma)\)</span>.</li>
<li>If <span class="math inline">\(\mathcal{B}(e_1,e_2,x,f_1,f_2,y)\)</span>, then <span class="math inline">\(\new(x,e_2,\sigma) = \new(y,f_2,\sigma)\)</span>.</li>
</ol>
<div class="proof">
<p>First we show (1). Recall that <span class="math inline">\(\mathcal{A}(e,x,f,y)\)</span> is shorthand for the hypothesis on lambda expressions in the definition of <span class="math inline">\(\AlphaEq\)</span>. Suppose it is true; we consider two cases.</p>
<ol>
<li><p>Suppose <span class="math inline">\(x = y\)</span> and <span class="math inline">\(e \AlphaEq f\)</span>. Using a <a href="LambdaTerm.html#crossref-4">previous result</a>, we have <span class="math inline">\(\freeLambdaVars(e) = \freeLambdaVars(f)\)</span>. Now <span class="math display">\[\begin{eqnarray*}
  &amp;   &amp; \new(x,e,\sigma) \\
  &amp; = &amp; \{ t \in \LambdaIdents \mid \mathrm{if}\ u \in \freeLambdaVars(e) \setminus \{x\}\ \mathrm{then}\ t \notin \freeLambdaVars(\sigma(u)) \} \\
  &amp; = &amp; \{ t \in \LambdaIdents \mid \mathrm{if}\ u \in \freeLambdaVars(f) \setminus \{y\}\ \mathrm{then}\ t \notin \freeLambdaVars(\sigma(u)) \} \\
  &amp; = &amp; \new(y,f,\sigma)
 \end{eqnarray*}\]</span> as claimed.</p></li>
<li><p>Suppose <span class="math inline">\(y \notin \freeLambdaVars(e)\)</span> and <span class="math inline">\(\mathsf{id}_{y/x}[e] \AlphaEq f\)</span>. We've <a href="LambdaTerm.html#crossref-4">seen</a> that <span class="math inline">\(\freeLambdaVars(\mathsf{id}_{y/x}[e]) = \freeLambdaVars(f)\)</span>. Using another <a href="LambdaTerm.html#crossref-2">previous result</a>, we also have <span class="math display">\[\freeLambdaVars(\mathsf{id}_{y/x}[e]) = (\freeLambdaVars(e) \setminus \{x\}) \cup \left\{ \begin{array}{ll} \{y\} &amp; \mathrm{if}\ x \in \freeLambdaVars(e) \\ \varnothing &amp; \mathrm{otherwise}. \end{array} \right.\]</span> In particular, we have <span class="math display">\[\freeLambdaVars(f) \setminus \{y\} = (\freeLambdaVars(e) \setminus \{x\}) \setminus \{y\} = \freeLambdaVars(e) \setminus \{x\}.\]</span> Then <span class="math display">\[\begin{eqnarray*}
  &amp;   &amp; \new(x,e,\sigma) \\
  &amp; = &amp; \{ t \in \LambdaIdents \mid \mathrm{if}\ u \in \freeLambdaVars(e) \setminus \{x\}\ \mathrm{then}\ t \notin \freeLambdaVars(\sigma(u)) \} \\
  &amp; = &amp; \{ t \in \LambdaIdents \mid \mathrm{if}\ u \in \freeLambdaVars(f) \setminus \{y\}\ \mathrm{then}\ t \notin \freeLambdaVars(\sigma(u)) \} \\
  &amp; = &amp; \new(y,f,\sigma)
 \end{eqnarray*}\]</span> as claimed.</p></li>
</ol>
<p>Next we show (2). Recall that <span class="math inline">\(\mathcal{B}(e_1,e_2,x,f_1,f_2,y)\)</span> is shorthand for the hypothesis on let expressions in the definition of <span class="math inline">\(\AlphaEq\)</span>. Suppose it is true; we consider two cases.</p>
<ol>
<li><p>Suppose <span class="math inline">\(x = y\)</span>, <span class="math inline">\(e_1 \AlphaEq f_1\)</span>, and <span class="math inline">\(e_2 \AlphaEq f_2\)</span>. Using a <a href="LambdaTerm.html#crossref-4">previous result</a> we have <span class="math inline">\(\freeLambdaVars(e_2) = \freeLambdaVars(f_2)\)</span>, so that <span class="math display">\[\begin{eqnarray*}
  &amp;   &amp; \new(x,e_2,\sigma) \\
  &amp; = &amp; \{ t \in \LambdaIdents \mid \mathrm{if}\ u \in \freeLambdaVars(e_2) \setminus \{x\}\ \mathrm{then}\ t \notin \freeLambdaVars(\sigma(u)) \} \\
  &amp; = &amp; \{ t \in \LambdaIdents \mid \mathrm{if}\ u \in \freeLambdaVars(f_2) \setminus \{y\}\ \mathrm{then}\ t \notin \freeLambdaVars(\sigma(u)) \} \\
  &amp; = &amp; \new(y,f_2,\sigma)
 \end{eqnarray*}\]</span> as claimed.</p></li>
<li>Suppose <span class="math inline">\(y \notin \freeLambdaVars(e_2)\)</span>, <span class="math inline">\(e_1 \AlphaEq f_1\)</span>, and <span class="math inline">\(\mathsf{id}_{y/x}[e_2] \AlphaEq f_2\)</span>. We've <a href="LambdaTerm.html#crossref-4">seen</a> that <span class="math inline">\(\freeLambdaVars(\mathsf{id}_{y/x}[e_2]) = \freeLambdaVars(f)\)</span>. Using another <a href="LambdaTerm.html#crossref-2">previous result</a>, we also have <span class="math display">\[\freeLambdaVars(\mathsf{id}_{y/x}[e_2]) = (\freeLambdaVars(e_2) \setminus \{x\}) \cup \left\{ \begin{array}{ll} \{y\} &amp; \mathrm{if}\ x \in \freeLambdaVars(e_2) \\ \varnothing &amp; \mathrm{otherwise}. \end{array} \right.\]</span> In particular, we have <span class="math display">\[\freeLambdaVars(f) \setminus \{y\} = (\freeLambdaVars(e_2) \setminus \{x\}) \setminus \{y\} = \freeLambdaVars(e_2) \setminus \{x\}.\]</span> Then <span class="math display">\[\begin{eqnarray*}
  &amp;   &amp; \new(x,e_2,\sigma) \\
  &amp; = &amp; \{ t \in \LambdaIdents \mid \mathrm{if}\ u \in \freeLambdaVars(e_2) \setminus \{x\}\ \mathrm{then}\ t \notin \freeLambdaVars(\sigma(u)) \} \\
  &amp; = &amp; \{ t \in \LambdaIdents \mid \mathrm{if}\ u \in \freeLambdaVars(f_2) \setminus \{y\}\ \mathrm{then}\ t \notin \freeLambdaVars(\sigma(u)) \} \\
  &amp; = &amp; \new(y,f_2,\sigma)
 \end{eqnarray*}\]</span> as claimed.</li>
</ol>
</div>
</div>
<p>We can also say something about how new variables and the composition of substitutions interact.</p>
<div class="theorem">
<p><a name='crossref-9'></a> If <span class="math inline">\(y \in \new(x,e,\sigma_1)\)</span>, then <span class="math inline">\(\new(x,e,\sigma_2\sigma_1) = \new(y,\sigma_{1,y/x}[e],\sigma_2)\)</span>.</p>
<div class="proof">
<p>Note that since <span class="math inline">\(y \in \new(x,e,\sigma_1)\)</span>, if <span class="math inline">\(u \in \freeLambdaVars(e) \setminus \{x\}\)</span>, then <span class="math inline">\(y \notin \freeLambdaVars(\sigma_1(u))\)</span>, and thus <span class="math inline">\(\freeLambdaVars(\sigma_1(u)) \setminus \{y\} = \freeLambdaVars(\sigma_1(u))\)</span>. then <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \new(y, \sigma_{1, y/x}[e], \sigma_2) \\
 &amp; = &amp; \{ t \in \LambdaIdents \mid \mathrm{if}\ u \in \freeLambdaVars(\sigma_{1, y/x}[e]) \setminus \{y\}\ \mathrm{then}\ t \notin \freeLambdaVars(\sigma_2(u)) \} \\
 &amp; = &amp; \left\{ t \in \LambdaIdents \mid \mathrm{if}\ u \in \left( \bigcup_{k \in \freeLambdaVars(e) \setminus \{x\}} \freeLambdaVars(\sigma_1(k)) \cup \left\{ \begin{array}{ll} \{y\} &amp; \mathrm{if}\ x \in \freeLambdaVars(e) \\ \varnothing &amp; \mathrm{otherwise} \end{array} \right\} \right) \setminus \{y\}\ \mathrm{then}\ t \notin \freeLambdaVars(\sigma_2(u)) \right\} \\
 &amp; = &amp; \{ t \in \LambdaIdents \mid \mathrm{if}\ u \in \left( \bigcup_{k \in \freeLambdaVars(e) \setminus \{x\}} \freeLambdaVars(\sigma_1(k)) \right) \setminus \{y\}\ \mathrm{then}\ t \notin \freeLambdaVars(\sigma_2(u)) \} \\
 &amp; = &amp; \{ t \in \LambdaIdents \mid \mathrm{if}\ u \in \bigcup_{k \in \freeLambdaVars(e) \setminus \{x\}} \freeLambdaVars(\sigma_1(k))\ \mathrm{then}\ t \notin \freeLambdaVars(\sigma_2(u)) \} \\
 &amp; = &amp; \{ t \in \LambdaIdents \mid \mathrm{if}\ k \in \freeLambdaVars(e) \setminus \{x\}\ \mathrm{then}\ \left(\mathrm{if}\ u \in \freeLambdaVars(\sigma_1(k))\ \mathrm{then}\ t \notin \freeLambdaVars(\sigma_2(u)) \right) \} \\
 &amp; = &amp; \{ t \in \LambdaIdents \mid \mathrm{if}\ k \in \freeLambdaVars(e) \setminus \{x\}\ \mathrm{then}\ t \notin \bigcup_{u \in \freeLambdaVars(\sigma_1(k))} \freeLambdaVars(\sigma_2(u)) \} \\
 &amp; = &amp; \{ t \in \LambdaIdents \mid \mathrm{if}\ k \in \freeLambdaVars(e) \setminus \{x\}\ \mathrm{then}\ t \notin \freeLambdaVars(\sigma_2[\sigma_1(k)]) \} \\
 &amp; = &amp; \{ t \in \LambdaIdents \mid \mathrm{if}\ k \in \freeLambdaVars(e) \setminus \{x\}\ \mathrm{then}\ t \notin \freeLambdaVars((\sigma_2\sigma_1)(k)) \} \\
 &amp; = &amp; \new(x, e, \sigma_2\sigma_1)
\end{eqnarray*}\]</span> as claimed.</p>
</div>
</div>
<p>Pointwise updates of the identity substitution on variables that are not free also yields alpha-equivalent terms.</p>
<div class="lemma">
<p>If <span class="math inline">\(x \notin \freeLambdaVars(z)\)</span>, then <span class="math inline">\(\mathsf{id}_{e/x}[z] \AlphaEq z\)</span>.</p>
<div class="proof">
<p>Note that <span class="math inline">\(\mathsf{id}_{e/x} =^{\freeLambdaVars(z)} \mathsf{id}\)</span>, and so by a <a href="LambdaTerm.html#crossref-6">previous result</a> we have <span class="math inline">\(\mathsf{id}_{e/x}[z] = \mathsf{id}[e]\)</span>. We've <a href="LambdaTerm.html#crossref-7">also shown</a> that <span class="math inline">\(\mathsf{id}[z] \AlphaEq z\)</span>, and so <span class="math inline">\(\mathsf{id}_{e/x}[z] \AlphaEq z\)</span> as claimed.</p>
</div>
</div>
<p>Next we show that composition of substitutions is compatible with simultaneous substitution.</p>
<div class="theorem">
<p><a name='crossref-10'></a> (Syntactic Substitution.) For all terms <span class="math inline">\(z\)</span> and substitutions <span class="math inline">\(\sigma_1\)</span> and <span class="math inline">\(\sigma_2\)</span>, we have <span class="math inline">\((\sigma_2\sigma_1)[z] = \sigma_2[\sigma_1[z]]\)</span>.</p>
<div class="proof">
<p>We proceed by structural induction on <span class="math inline">\(z\)</span>.</p>
<ol>
<li><p>Suppose <span class="math inline">\(z \in \LambdaIdents\)</span>. Then <span class="math display">\[\begin{eqnarray*}
  &amp;   &amp; (\sigma_2\sigma_1)[z] \\
  &amp; = &amp; \sigma_2[\sigma_1(z)] \\
  &amp; = &amp; \sigma_2[\sigma_1[z]]
 \end{eqnarray*}\]</span> as claimed.</p></li>
<li><p>Suppose <span class="math inline">\(z \in \LambdaConsts\)</span>. Then <span class="math display">\[\begin{eqnarray*}
  &amp;   &amp; (\sigma_2\sigma_1)[z] \\
  &amp; = &amp; z \\
  &amp; = &amp; \sigma_2[z] \\
  &amp; = &amp; \sigma_2[\sigma_1[z]]
 \end{eqnarray*}\]</span> as claimed.</p></li>
<li><p>Suppose <span class="math inline">\(z = \lamex{x}{e}\)</span>. Using the inductive hypothesis we have <span class="math display">\[\begin{eqnarray*}
  &amp;   &amp; \sigma_2[\sigma_1[z]] \\
  &amp; = &amp; \sigma_2[\sigma_1[\lamex{x}{e}]] \\
  &amp; = &amp; \sigma_2[\lamex{y}{\sigma_{1,y/x}[e]}] \\
  &amp; = &amp; \lamex{u}{\sigma_{2,u/y}[\sigma_{1,y/x}[e]]} \\
  &amp; = &amp; \lamex{u}{(\sigma_{2,u/y}\sigma_{1,y/x})[e]}
 \end{eqnarray*}\]</span> where <span class="math inline">\(y = \choice(\new(x,e,\sigma_1))\)</span> and <span class="math inline">\(u = \choice(\new(y,\sigma_{1,y/x}[e],\sigma_2))\)</span>, and we also have <span class="math display">\[\begin{eqnarray*}
  &amp;   &amp; (\sigma_2\sigma_1)[z] \\
  &amp; = &amp; (\sigma_2\sigma_1)[\lamex{x}{e}] \\
  &amp; = &amp; \lamex{v}{(\sigma_2\sigma_1)_{v/x}[e]}
 \end{eqnarray*}\]</span> where <span class="math inline">\(v = \choice(\new(x,e,\sigma_2\sigma_1))\)</span>. Using the <a href="LambdaTerm.html#crossref-9">previous result</a>, we have <span class="math inline">\(\new(x,e,\sigma_2\sigma_1) = \new(y,\sigma_{1,y/x}[e],\sigma_2)\)</span>, and thus <span class="math inline">\(u = v\)</span>. Now note that if <span class="math inline">\(t \in \freeLambdaVars(e) \setminus \{x\}\)</span>, then <span class="math inline">\(y \notin \freeLambdaVars(\sigma_1(t))\)</span> (from the definition of <span class="math inline">\(\new\)</span>) and in particular, for such <span class="math inline">\(t\)</span> we have <span class="math inline">\(\sigma_{2,v/y} =^{\freeLambdaVars(\sigma_1(t))} \sigma_2\)</span>. Using a <a href="LambdaTerm.html#crossref-6">previous result</a> we have <span class="math inline">\(\sigma_{2,v/y}[\sigma_1(t)] = \sigma_2[\sigma_1(t)]\)</span>. Now note that for any variable <span class="math inline">\(t \in \freeLambdaVars(e)\)</span>, we have <span class="math display">\[\begin{eqnarray*}
  &amp;   &amp; (\sigma_{2,v/y}\sigma_{1,y/x})(t) \\
  &amp; = &amp; \sigma_{2,v/y}[\sigma_{1,y/x}(t)] \\
  &amp; = &amp; \sigma_{2,v/y}\left[ \left\{\begin{array}{ll} y &amp; \mathrm{if}\ t = x \\ \sigma_1(t) &amp; \mathrm{otherwise} \end{array}\right. \right] \\
  &amp; = &amp; \left\{\begin{array}{ll} \sigma_{2,v/y}[y] &amp; \mathrm{if}\ t = x \\ \sigma_{2,v/y}[\sigma_1(t)] &amp; \mathrm{otherwise} \end{array}\right. \\
  &amp; = &amp; \left\{\begin{array}{ll} \sigma_{2,v/y}(y) &amp; \mathrm{if}\ t = x \\ \sigma_2[\sigma_1(t)] &amp; \mathrm{otherwise} \end{array}\right. \\
  &amp; = &amp; \left\{\begin{array}{ll} v &amp; \mathrm{if}\ t = x \\ \sigma_2[\sigma_1(t)] &amp; \mathrm{otherwise} \end{array}\right. \\
  &amp; = &amp; \left\{\begin{array}{ll} v &amp; \mathrm{if}\ t = x \\ (\sigma_2\sigma_1)(t) &amp; \mathrm{otherwise} \end{array}\right. \\
  &amp; = &amp; (\sigma_2\sigma_1)_{v/x}(t).
 \end{eqnarray*}\]</span> That is, we have <span class="math inline">\(\sigma_{2,v/y}\sigma_{1,y/x} =^{\freeLambdaVars(e)} (\sigma_2\sigma_1)_{v/x}\)</span>. Using the <a href="LambdaTerm.html#crossref-6">previous result</a> again we then have <span class="math inline">\((\sigma_{2,v/y}\sigma_{1,y/x})[e] = (\sigma_2\sigma_1)_{v/x}[e]\)</span>. Putting it all together, we have <span class="math display">\[\begin{eqnarray*}
  &amp;   &amp; \sigma_2[\sigma_1[z]] \\
  &amp; = &amp; \lamex{u}{(\sigma_{2,u/y}\sigma_{1,y/x})[e]} \\
  &amp; = &amp; \lamex{v}{(\sigma_{2,v/y}\sigma_{1,y/x})[e]} \\
  &amp; = &amp; \lamex{v}{(\sigma_2\sigma_1)_{v/x}[e]} \\
  &amp; = &amp; (\sigma_2\sigma_1)[z]
 \end{eqnarray*}\]</span> as claimed.</p></li>
<li><p>Suppose <span class="math inline">\(z = \letin{x}{e_1}{e_2}\)</span>. Much like the <span class="math inline">\(\lambda\)</span> case, using the inductive hypothesis we have <span class="math display">\[\begin{eqnarray*}
  &amp;   &amp; \sigma_2[\sigma_1[z]] \\
  &amp; = &amp; \sigma_2[\sigma_1[\letin{x}{e_1}{e_2}]] \\
  &amp; = &amp; \sigma_2[\letin{y}{\sigma_1[e_1]}{\sigma_{1,y/x}[e_2]}] \\
  &amp; = &amp; \letin{u}{\sigma_2[\sigma_1[e_1]]}{\sigma_{2,u/y}[\sigma_{1,y/x}[e_2]]} \\
  &amp; = &amp; \letin{u}{\sigma_2[\sigma_1[e_1]]}{(\sigma_{2,u/y}\sigma_{1,y/x})[e_2]}
 \end{eqnarray*}\]</span> where <span class="math inline">\(y = \choice(\new(x,e_2,\sigma_1))\)</span> and <span class="math inline">\(u = \choice(\new(y,\sigma_{1,y/x}[e_2]),\sigma_2)\)</span>, and we also have <span class="math display">\[\begin{eqnarray*}
  &amp;   &amp; (\sigma_2\sigma_1)[z] \\
  &amp; = &amp; (\sigma_2\sigma_1)[\letin{x}{e_1}{e_2}] \\
  &amp; = &amp; \letin{v}{(\sigma_2\sigma_1)[e_1]}{(\sigma_2\sigma_1)_{v/x}[e_2]}
 \end{eqnarray*}\]</span> where <span class="math inline">\(v = \choice(\new(x,e_2,\sigma_2\sigma_1))\)</span>. As with the <span class="math inline">\(\lambda\)</span> case, by <a href="LambdaTerm.html#crossref-9">previous result</a>, we have <span class="math inline">\(\new(x,e_2,\sigma_2\sigma_1) = \new(y,\sigma_{1,y/x}[e_2],\sigma_2)\)</span>, and thus <span class="math inline">\(u = v\)</span>. Following that argument further we have <span class="math inline">\(\sigma_{2,v/y}[\sigma_1(t)] = \sigma_2[\sigma_1[t]]\)</span> for all <span class="math inline">\(t \in \freeLambdaVars(e_2) \setminus \{x\}\)</span>, and then <span class="math inline">\((\sigma_{2,v/y}\sigma_{1,y/x})(t) = (\sigma_2\sigma_1)_{v/x}(t)\)</span> for all <span class="math inline">\(t \in \freeLambdaVars(e_2)\)</span>. Thus <span class="math inline">\(\sigma_{2,v/y}\sigma_{1,y/x} =^{\freeLambdaVars(e_2)} (\sigma_2\sigma_1)_{v/x}\)</span>, and so <span class="math inline">\((\sigma_{2,v/y}\sigma_{1,y/x})[e_2] = (\sigma_2\sigma_1)_{v/x}[e_2]\)</span>. Then using the inductive hypothesis we have <span class="math display">\[\begin{eqnarray*}
  &amp;   &amp; \sigma_2[\sigma_1[z]] \\
  &amp; = &amp; \letin{u}{\sigma_2[\sigma_1[e_1]]}{(\sigma_{2,u/y}\sigma_{1,y/x})[e_2]} \\
  &amp; = &amp; \letin{v}{\sigma_2[\sigma_1[e_1]]}{(\sigma_{2,v/y}\sigma_{1,y/x})[e_2]} \\
  &amp; = &amp; \letin{v}{\sigma_2[\sigma_1[e_1]]}{(\sigma_2\sigma_1)_{v/x}[e_2]} \\
  &amp; = &amp; \letin{v}{(\sigma_2\sigma_1)[e_1]}{(\sigma_2\sigma_1)_{v/x}[e_2]} \\
  &amp; = &amp; (\sigma_2\sigma_1)[z]
 \end{eqnarray*}\]</span> as claimed.</p></li>
<li>Suppose <span class="math inline">\(z = \apply{e_1}{e_2}\)</span>. Then <span class="math display">\[\begin{eqnarray*}
  &amp;   &amp; (\sigma_2\sigma_1)[z] \\
  &amp; = &amp; (\sigma_2\sigma_1)[\apply{e_1}{e_2}] \\
  &amp; = &amp; \apply{(\sigma_2\sigma_1)[e_1]}{(\sigma_2\sigma_1)[e_2]} \\
  &amp; = &amp; \apply{\sigma_2[\sigma_1[e_1]]}{\sigma_2[\sigma_1[e_2]]} \\
  &amp; = &amp; \sigma_2[\apply{\sigma_1[e_1]}{\sigma_1[e_2]}] \\
  &amp; = &amp; \sigma_2[\sigma_1[\apply{e_1}{e_2}]] \\
  &amp; = &amp; \sigma_2[\sigma_1[z]]
 \end{eqnarray*}\]</span> as claimed.</li>
</ol>
</div>
</div>
<p>This theorem is a great candidate for property testing; it is unqualified and states a simple equality of two expressions, but it conceals a lot of implementation details.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" title="1">prop_lambda_sub_action</a>
<a class="sourceLine" id="cb18-2" title="2"><span class="ot">  ::</span> <span class="kw">forall</span> a</a>
<a class="sourceLine" id="cb18-3" title="3">   <span class="op">.</span> (<span class="dt">Show</span> a)</a>
<a class="sourceLine" id="cb18-4" title="4">  <span class="ot">=&gt;</span> <span class="dt">LambdaTerm</span> a</a>
<a class="sourceLine" id="cb18-5" title="5">  <span class="ot">-&gt;</span> <span class="dt">M.Map</span> <span class="dt">LambdaVariable</span> (<span class="dt">LambdaTerm</span> a)</a>
<a class="sourceLine" id="cb18-6" title="6">  <span class="ot">-&gt;</span> <span class="dt">M.Map</span> <span class="dt">LambdaVariable</span> (<span class="dt">LambdaTerm</span> a)</a>
<a class="sourceLine" id="cb18-7" title="7">  <span class="ot">-&gt;</span> <span class="dt">Property</span></a>
<a class="sourceLine" id="cb18-8" title="8">prop_lambda_sub_action z sigma1 sigma2 <span class="ot">=</span> (<span class="op">===</span>)</a>
<a class="sourceLine" id="cb18-9" title="9">  (applySubToLambdaTerm (composeLambdaSubs sigma2 sigma1) z)</a>
<a class="sourceLine" id="cb18-10" title="10">  (applySubToLambdaTerm sigma2 (applySubToLambdaTerm sigma1 z))</a></code></pre></div>
<p>The Syntactic Substitution theorem states that substitution is compatible with composition.</p>
<div class="corollary">
<p><a name='crossref-11'></a> If <span class="math inline">\(y \notin \freeLambdaVars(z)\)</span> then <span class="math inline">\(\sigma_{w/y}[\mathsf{id}_{y/x}[z]] = \sigma_{w/x}[z]\)</span>.</p>
<div class="proof">
<p>If <span class="math inline">\(t \in \freeLambdaVars(z)\)</span>, then <span class="math inline">\(y \neq t\)</span>, and we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; (\sigma_{w/y}\mathsf{id}_{y/x})(t) \\
 &amp; = &amp; \sigma_{w/y}[\mathsf{id}_{y/x}(t)] \\
 &amp; = &amp; \sigma_{w/y}\left[ \left\{ \begin{array}{ll} y &amp; \mathrm{if}\ t = x \\ t &amp; \mathrm{otherwise} \end{array} \right. \right] \\
 &amp; = &amp; \left\{\begin{array}{ll} \sigma_{w/y}[y] &amp; \mathrm{if}\ t = x \\ \sigma[t] &amp; \mathrm{otherwise} \end{array}\right. \\
 &amp; = &amp; \left\{\begin{array}{ll} \sigma_{w/y}(y) &amp; \mathrm{if}\ t = x \\ \sigma(t) &amp; \mathrm{otherwise} \end{array}\right. \\
 &amp; = &amp; \left\{\begin{array}{ll} w &amp; \mathrm{if}\ t = x \\ \sigma(t) &amp; \mathrm{otherwise} \end{array}\right. \\
 &amp; = &amp; \sigma_{w/x}[t] \\
 &amp; = &amp; \sigma_{w/x}(t).
\end{eqnarray*}\]</span> That is, <span class="math inline">\(\sigma_{w/y}\mathsf{id}_{y/x} =^{\freeLambdaVars(z)} \sigma_{w/x}\)</span>. Using a <a href="LambdaTerm.html#crossref-6">previous result</a> as well as the <a href="LambdaTerm.html#crossref-10">Syntactic Substitution</a> theorem we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \sigma_{w/y}[\mathsf{id}_{y/x}[z]] \\
 &amp; = &amp; (\sigma_{w/y}\mathsf{id}_{y/x})[z] \\
 &amp; = &amp; \sigma_{w/x}[z]
\end{eqnarray*}\]</span> as claimed.</p>
</div>
</div>
<p>It looks a lot like we have a monoid or semigroup action here; to nail that down we need to show that composition of substitutions forms a monoid or semigroup.</p>
<div class="corollary">
<p>We have the following for substitutions <span class="math inline">\(\sigma_i\)</span>.</p>
<ol>
<li><span class="math inline">\(\sigma\ \mathsf{id} = \sigma\)</span>.</li>
<li><span class="math inline">\(\mathsf{id}\ \sigma \AlphaEq \sigma\)</span>.</li>
<li><span class="math inline">\(\sigma_3(\sigma_2\sigma_1) = (\sigma_3\sigma_2)\sigma_1\)</span>.</li>
</ol>
<div class="proof">
<ol>
<li><p>Note that for all identifiers <span class="math inline">\(t\)</span>, we have <span class="math display">\[\begin{eqnarray*}
  &amp;   &amp; (\sigma\ \mathsf{id})(t) \\
  &amp; = &amp; \sigma[\mathsf{id}(t)] \\
  &amp; = &amp; \sigma[t] \\
  &amp; = &amp; \sigma(t)
 \end{eqnarray*}\]</span> as needed.</p></li>
<li><p>Let <span class="math inline">\(t\)</span> be an identifier. Using a <a href="LambdaTerm.html#crossref-7">previous result</a> we have <span class="math display">\[\begin{eqnarray*}
  &amp;          &amp; (\mathsf{id}\ \sigma)(t) \\
  &amp; =        &amp; \mathsf{id}[\sigma(t)] \\
  &amp; \AlphaEq &amp; \sigma(t)
 \end{eqnarray*}\]</span> as needed.</p></li>
<li>Let <span class="math inline">\(t\)</span> be an identifier. Then using the <a href="LambdaTerm.html#crossref-10">Syntactic Substitution</a> theorem we have <span class="math display">\[\begin{eqnarray*}
  &amp;   &amp; (\sigma_3(\sigma_2\sigma_1))(t) \\
  &amp; = &amp; \sigma_3[(\sigma_2\sigma_1)(t)] \\
  &amp; = &amp; \sigma_3[\sigma_2[\sigma_1(t)]] \\
  &amp; = &amp; (\sigma_3\sigma_2)[\sigma_1(t)] \\
  &amp; = &amp; ((\sigma_3\sigma_2)\sigma_1)(t)
 \end{eqnarray*}\]</span> as needed.</li>
</ol>
</div>
</div>
<p>These properties are also amenable to property testing.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" title="1">prop_lambda_sub_composite_right_identity</a>
<a class="sourceLine" id="cb19-2" title="2"><span class="ot">  ::</span> <span class="kw">forall</span> a</a>
<a class="sourceLine" id="cb19-3" title="3">   <span class="op">.</span> (<span class="dt">Show</span> a)</a>
<a class="sourceLine" id="cb19-4" title="4">  <span class="ot">=&gt;</span> <span class="dt">M.Map</span> <span class="dt">LambdaVariable</span> (<span class="dt">LambdaTerm</span> a)</a>
<a class="sourceLine" id="cb19-5" title="5">  <span class="ot">-&gt;</span> <span class="dt">Property</span></a>
<a class="sourceLine" id="cb19-6" title="6">prop_lambda_sub_composite_right_identity sigma <span class="ot">=</span> (<span class="op">===</span>)</a>
<a class="sourceLine" id="cb19-7" title="7">  (composeLambdaSubs sigma identitySub) sigma</a>
<a class="sourceLine" id="cb19-8" title="8"></a>
<a class="sourceLine" id="cb19-9" title="9">prop_lambda_sub_composite_left_identity</a>
<a class="sourceLine" id="cb19-10" title="10"><span class="ot">  ::</span> <span class="kw">forall</span> a</a>
<a class="sourceLine" id="cb19-11" title="11">   <span class="op">.</span> (<span class="dt">Show</span> a)</a>
<a class="sourceLine" id="cb19-12" title="12">  <span class="ot">=&gt;</span> <span class="dt">M.Map</span> <span class="dt">LambdaVariable</span> (<span class="dt">LambdaTerm</span> a)</a>
<a class="sourceLine" id="cb19-13" title="13">  <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb19-14" title="14">prop_lambda_sub_composite_left_identity sigma <span class="ot">=</span> alphaEqSub</a>
<a class="sourceLine" id="cb19-15" title="15">  (composeLambdaSubs identitySub sigma) sigma</a>
<a class="sourceLine" id="cb19-16" title="16"></a>
<a class="sourceLine" id="cb19-17" title="17">prop_lambda_sub_composite_associative</a>
<a class="sourceLine" id="cb19-18" title="18"><span class="ot">  ::</span> <span class="kw">forall</span> a</a>
<a class="sourceLine" id="cb19-19" title="19">   <span class="op">.</span> (<span class="dt">Show</span> a)</a>
<a class="sourceLine" id="cb19-20" title="20">  <span class="ot">=&gt;</span> <span class="dt">M.Map</span> <span class="dt">LambdaVariable</span> (<span class="dt">LambdaTerm</span> a)</a>
<a class="sourceLine" id="cb19-21" title="21">  <span class="ot">-&gt;</span> <span class="dt">M.Map</span> <span class="dt">LambdaVariable</span> (<span class="dt">LambdaTerm</span> a)</a>
<a class="sourceLine" id="cb19-22" title="22">  <span class="ot">-&gt;</span> <span class="dt">M.Map</span> <span class="dt">LambdaVariable</span> (<span class="dt">LambdaTerm</span> a)</a>
<a class="sourceLine" id="cb19-23" title="23">  <span class="ot">-&gt;</span> <span class="dt">Property</span></a>
<a class="sourceLine" id="cb19-24" title="24">prop_lambda_sub_composite_associative sigma1 sigma2 sigma3 <span class="ot">=</span> (<span class="op">===</span>)</a>
<a class="sourceLine" id="cb19-25" title="25">  (composeLambdaSubs sigma3 (composeLambdaSubs sigma2 sigma1))</a>
<a class="sourceLine" id="cb19-26" title="26">  (composeLambdaSubs (composeLambdaSubs sigma3 sigma2) sigma1)</a></code></pre></div>
<p>Summarizing a few results, we have the following.</p>
<div class="corollary">
<p>Let <span class="math inline">\(\cdot\)</span> denote substitution composition.</p>
<ol>
<li><span class="math inline">\((\LambdaSubstitutions, \cdot)\)</span> is a semigroup.</li>
<li><span class="math inline">\((\LambdaSubstitutions/\AlphaEq, \cdot, \mathsf{id})\)</span> is a monoid.</li>
</ol>
<p>Both of these structures act on <span class="math inline">\(\LambdaTerms\)</span> from the left by simultaneous substitution.</p>
</div>
<p>We're now prepared to show that simultaneous substitution is compatible with <span class="math inline">\(\alpha\)</span>-equivalence. In fact the situation is stronger than that; applying a substitution to <span class="math inline">\(\alpha\)</span>-equivalent terms yields <em>syntactically equal</em> results.</p>
<div class="theorem">
<p>If <span class="math inline">\(z \AlphaEq w\)</span>, then <span class="math inline">\(\sigma[z] = \sigma[w]\)</span>.</p>
<div class="proof">
<p>We will follow a strategy similar to our proof that alpha equivalent terms have the same free variables. Define a relation <span class="math inline">\(\sim\)</span> on <span class="math inline">\(\LambdaTerms\)</span> by <span class="math inline">\(z \sim w\)</span> if and only if <span class="math inline">\(z \AlphaEq w\)</span> and <span class="math inline">\(\sigma[z] = \sigma[w]\)</span> for all substitutions <span class="math inline">\(\sigma\)</span>. This <span class="math inline">\(\sim\)</span> is clearly an equivalence. We will show that it also satisfies the defining properties of <span class="math inline">\(\AlphaEq\)</span>, so that <span class="math inline">\(\AlphaEq\)</span> is contained in <span class="math inline">\(\sim\)</span>. Since <span class="math inline">\(\sim\)</span> is contained in <span class="math inline">\(\AlphaEq\)</span> by definition, the conclusion follows.</p>
<p>Suppose <span class="math inline">\(z = \lamex{x}{e}\)</span> and <span class="math inline">\(w = \lamex{y}{f}\)</span> with <span class="math inline">\(\mathcal{A}(e,x,f,y)\)</span>, and let <span class="math inline">\(\sigma\)</span> be a substitution. We showed <a href="LambdaTerm.html#crossref-8">previously</a> that <span class="math inline">\(\new(x,e,\sigma) = \new(y,f,\sigma)\)</span>, and so letting <span class="math inline">\(u = \choice(\new(x,e,\sigma))\)</span> we have <span class="math display">\[\sigma[z] = \sigma[\lamex{x}{e}] = \lamex{u}{\sigma_{u/x}[e]}\]</span> and <span class="math display">\[\sigma[w] = \sigma[\lamex{y}{f}] = \lamex{u}{\sigma_{u,y}[f]}.\]</span> We consider two cases.</p>
<ol>
<li><p>Suppose <span class="math inline">\(x = y\)</span> and <span class="math inline">\(e \sim f\)</span>. Then using the inductive hypothesis we have <span class="math display">\[\sigma_{u/x}[e] = \sigma_{u/x}[f] = \sigma_{u/y}[f]\]</span> and thus <span class="math display">\[\sigma[z] = \lamex{u}{\sigma_{u/x}[e]} = \lamex{u}{\sigma_{u/y}[f]} = \sigma[w].\]</span> Since <span class="math inline">\(\sigma\)</span> was arbitrary, we have <span class="math inline">\(z \sim w\)</span> as claimed.</p></li>
<li><p>Suppose <span class="math inline">\(y \notin \freeLambdaVars(e)\)</span> and <span class="math inline">\(\mathsf{id}_{y/x}[e] \sim f\)</span>. Using a <a href="LambdaTerm.html#crossref-11">previous result</a> we have <span class="math display">\[\sigma_{u/x}[e] = \sigma_{u/y}[\mathsf{id}_{y/x}[e]] = \sigma_{u/y}[f]\]</span> and thus <span class="math display">\[\sigma[z] = \lamex{u}{\sigma_{u/x}[e]} = \lamex{u}{\sigma_{u/y}[f]} = \sigma[w].\]</span> Since <span class="math inline">\(\sigma\)</span> was arbitrary, we have <span class="math inline">\(z \sim w\)</span> as claimed.</p></li>
</ol>
<p>Suppose <span class="math inline">\(z = \letin{x}{e_1}{e_2}\)</span> and <span class="math inline">\(w = \letin{y}{f_1}{f_2}\)</span> with <span class="math inline">\(\mathcal{B}(e_1,e_2,x,f_1,f_2,y)\)</span>, and let <span class="math inline">\(\sigma\)</span> be a substitution. We showed <a href="LambdaTerm.html#crossref-8">previously</a> that <span class="math inline">\(\new(x,e_2,\sigma) = \new(y,f_2,\sigma)\)</span>, and so letting <span class="math inline">\(u = \choice(\new(x,e,\sigma_2))\)</span> we have <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \sigma[z] \\
 &amp; = &amp; \sigma[\letin{x}{e_1}{e_2}] \\
 &amp; = &amp; \letin{u}{\sigma[e_1]}{\sigma_{u/x}[e_2]}
\end{eqnarray*}\]</span> and <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \sigma[w] \\
 &amp; = &amp; \sigma[\letin{y}{f_1}{f_2}] \\
 &amp; = &amp; \letin{u}{\sigma[f_1]}{\sigma_{u/y}[f_2]}.
\end{eqnarray*}\]</span> We consider two cases.</p>
<ol>
<li><p>Suppose <span class="math inline">\(x = y\)</span>, <span class="math inline">\(e_2 \sim f_2\)</span>, and <span class="math inline">\(e_1 \sim f_1\)</span>. Then <span class="math inline">\(e_1 \AlphaEq f_1\)</span> and <span class="math inline">\(e_2 \AlphaEq f_2\)</span>. Using the inductive hypothesis we have <span class="math display">\[\sigma_{u/x}[e_2] = \sigma_{u/x}[f_2] = \sigma_{u/y}[f_2]\]</span> and thus <span class="math display">\[\begin{eqnarray*}
  &amp;   &amp; \sigma[z] \\
  &amp; = &amp; \letin{u}{\sigma[e_1]}{\sigma_{u/x}[e_2]} \\
  &amp; = &amp; \letin{u}{\sigma[f_1]}{\sigma_{u/y}[f_2]} \\
  &amp; = &amp; \sigma[w].
 \end{eqnarray*}\]</span> Since <span class="math inline">\(\sigma\)</span> was arbitrary we have <span class="math inline">\(z \sim w\)</span> as claimed.</p></li>
<li><p>Suppose <span class="math inline">\(y \notin \freeLambdaVars(e_2)\)</span>, <span class="math inline">\(\mathsf{id}_{y/x}[e_2] \sim f_2\)</span>, and <span class="math inline">\(e_1 \sim f_1\)</span>. Using a <a href="LambdaTerm.html#crossref-11">previous result</a> we have <span class="math display">\[\sigma_{u/x}[e_2] = \sigma_{u/y}[\mathsf{id}_{y/x}[e_2]] = \sigma_{u/y}[f_2]\]</span> and thus <span class="math display">\[\begin{eqnarray*}
  &amp;   &amp; \sigma[z] \\
  &amp; = &amp; \letin{u}{\sigma[e_1]}{\sigma_{u/x}[e_2]} \\
  &amp; = &amp; \letin{u}{\sigma[f_1]}{\sigma_{u/y}[f_2]} \\
  &amp; = &amp; \sigma[w].
 \end{eqnarray*}\]</span> Since <span class="math inline">\(\sigma\)</span> was arbitrary, we have <span class="math inline">\(z \sim w\)</span> as claimed.</p></li>
</ol>
<p>Suppose <span class="math inline">\(z = \apply{e_1}{e_2}\)</span> and <span class="math inline">\(w = \apply{f_1}{f_2}\)</span>, and let <span class="math inline">\(\sigma\)</span> be a substitution. Since <span class="math inline">\(z \AlphaEq w\)</span> we have <span class="math inline">\(e_1 \AlphaEq f_1\)</span> and <span class="math inline">\(e_2 \AlphaEq f_2\)</span>. Using the inductive hypothesis we then have <span class="math inline">\(\sigma[e_1] = \sigma[f_1]\)</span> and <span class="math inline">\(\sigma[e_2] = \sigma[f_2]\)</span>, so that <span class="math display">\[\begin{eqnarray*}
 &amp;   &amp; \sigma[z] \\
 &amp; = &amp; \sigma[\apply{e_1}{e_2}] \\
 &amp; = &amp; \apply{\sigma[e_1]}{\sigma[e_2]} \\
 &amp; = &amp; \apply{\sigma[f_1]}{\sigma[f_2]} \\
 &amp; = &amp; \sigma[\apply{f_1}{f_2}] \\
 &amp; = &amp; \sigma[w].
\end{eqnarray*}\]</span> Since <span class="math inline">\(\sigma\)</span> was arbitrary we have <span class="math inline">\(z \sim w\)</span> as claimed.</p>
</div>
</div>
<p>This finally gives us a computable strategy for detecting when two terms are <span class="math inline">\(\alpha\)</span>-equivalent; apply the identity substitution to both and see if the results are <em>syntactically</em> equal.</p>
<div class="corollary">
<p>We have the following.</p>
<ol>
<li><span class="math inline">\(z \AlphaEq w\)</span> if and only if <span class="math inline">\(\mathsf{id}[z] = \mathsf{id}[w]\)</span>.</li>
<li><span class="math inline">\(\sigma_1 \AlphaEq^{A} \sigma_2\)</span> if and only if <span class="math inline">\(\mathsf{id}\ \sigma_1 =^{A} \mathsf{id}\ \sigma_2\)</span>.</li>
</ol>
<div class="proof">
<ol>
<li><p>If <span class="math inline">\(z \AlphaEq w\)</span>, then <span class="math inline">\(\mathsf{id}[z] = \mathsf{id}[w]\)</span> by the previous theorem. If <span class="math inline">\(\mathsf{id}[z] = \mathsf{id}[w]\)</span>, then using a <a href="LambdaTerm.html#crossref-7">previous result</a> we have <span class="math display">\[z \AlphaEq \mathsf{id}[z] = \mathsf{id}[w] \AlphaEq w\]</span> as claimed.</p></li>
<li>Follows from (1).</li>
</ol>
</div>
</div>
<p>We can translate this theorem to a Haskell function for detecting <span class="math inline">\(\alpha\)</span>-equivalence.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" title="1">alphaEqTerm</a>
<a class="sourceLine" id="cb20-2" title="2"><span class="ot">  ::</span> <span class="dt">LambdaTerm</span> a <span class="ot">-&gt;</span> <span class="dt">LambdaTerm</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb20-3" title="3">alphaEqTerm z w <span class="ot">=</span> (<span class="op">==</span>)</a>
<a class="sourceLine" id="cb20-4" title="4">  (applySubToLambdaTerm identitySub z)</a>
<a class="sourceLine" id="cb20-5" title="5">  (applySubToLambdaTerm identitySub w)</a>
<a class="sourceLine" id="cb20-6" title="6"></a>
<a class="sourceLine" id="cb20-7" title="7">alphaEqSub</a>
<a class="sourceLine" id="cb20-8" title="8"><span class="ot">  ::</span> <span class="dt">M.Map</span> <span class="dt">LambdaVariable</span> (<span class="dt">LambdaTerm</span> a) <span class="ot">-&gt;</span> <span class="dt">M.Map</span> <span class="dt">LambdaVariable</span> (<span class="dt">LambdaTerm</span> a) <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb20-9" title="9">alphaEqSub sigma1 sigma2 <span class="ot">=</span> (<span class="op">==</span>)</a>
<a class="sourceLine" id="cb20-10" title="10">  (M.map (applySubToLambdaTerm identitySub) sigma1)</a>
<a class="sourceLine" id="cb20-11" title="11">  (M.map (applySubToLambdaTerm identitySub) sigma2)</a></code></pre></div>
<p>With an actual implementation of <span class="math inline">\(\alpha\)</span>-equivalence in hand, we can write tests for the properties which use it. For instance we can check that it's an equivalence relation.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" title="1">prop_alpha_eq_reflexive</a>
<a class="sourceLine" id="cb21-2" title="2"><span class="ot">  ::</span> <span class="kw">forall</span> a<span class="op">.</span> (<span class="dt">Show</span> a)</a>
<a class="sourceLine" id="cb21-3" title="3">  <span class="ot">=&gt;</span> <span class="dt">LambdaTerm</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb21-4" title="4">prop_alpha_eq_reflexive z <span class="ot">=</span> alphaEqTerm z z</a>
<a class="sourceLine" id="cb21-5" title="5"></a>
<a class="sourceLine" id="cb21-6" title="6">prop_alpha_eq_symmetric</a>
<a class="sourceLine" id="cb21-7" title="7"><span class="ot">  ::</span> <span class="kw">forall</span> a<span class="op">.</span> (<span class="dt">Show</span> a)</a>
<a class="sourceLine" id="cb21-8" title="8">  <span class="ot">=&gt;</span> <span class="dt">LambdaTerm</span> a <span class="ot">-&gt;</span> <span class="dt">LambdaTerm</span> a <span class="ot">-&gt;</span> <span class="dt">Property</span></a>
<a class="sourceLine" id="cb21-9" title="9">prop_alpha_eq_symmetric z1 z2 <span class="ot">=</span> (<span class="op">===</span>)</a>
<a class="sourceLine" id="cb21-10" title="10">  (alphaEqTerm z1 z2)</a>
<a class="sourceLine" id="cb21-11" title="11">  (alphaEqTerm z2 z1)</a>
<a class="sourceLine" id="cb21-12" title="12"></a>
<a class="sourceLine" id="cb21-13" title="13">prop_alpha_eq_transitive</a>
<a class="sourceLine" id="cb21-14" title="14"><span class="ot">  ::</span> <span class="kw">forall</span> a<span class="op">.</span> (<span class="dt">Show</span> a)</a>
<a class="sourceLine" id="cb21-15" title="15">  <span class="ot">=&gt;</span> <span class="dt">LambdaTerm</span> a <span class="ot">-&gt;</span> <span class="dt">LambdaTerm</span> a <span class="ot">-&gt;</span> <span class="dt">LambdaTerm</span> a <span class="ot">-&gt;</span> <span class="dt">Property</span></a>
<a class="sourceLine" id="cb21-16" title="16">prop_alpha_eq_transitive z1 z2 z3 <span class="ot">=</span></a>
<a class="sourceLine" id="cb21-17" title="17">  <span class="kw">if</span> (alphaEqTerm z1 z2) <span class="op">&amp;&amp;</span> (alphaEqTerm z2 z3)</a>
<a class="sourceLine" id="cb21-18" title="18">    <span class="kw">then</span> alphaEqTerm z1 z3 <span class="op">===</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb21-19" title="19">    <span class="kw">else</span> property succeeded</a></code></pre></div>
</section>
</article>
</body>
</html>
